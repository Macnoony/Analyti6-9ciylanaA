ID;L1;L2;L3;FILENAME;HEADER1;HEADER2;TEXT;VECTOR_STR
0;273;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Weighted Path Functions;"
### WEIGHT  
```graphscript
BIGINT costs = WEIGHT(:weighted_path_bigint);
```  
Gets the weight of the given path.  

### LENGTH  
```graphscript
BIGINT len = LENGTH(:weighted_path);
```  
Gets the length (number of edges) for a given weighted path.  
"
1;52;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;DEGREE;"Returns the number of incoming and outgoing edges of a vertex.  
- DEGREE(VERTEX) => BIGINT  
"
2;44;60;20;20;060-020-020-Basic_Graph_Operations.md;Basic Graph Operations;EDGES;"Returns all edges in a graph.  
- EDGES(GRAPH) => MULTISET  
<!--! section id=""section_xhl_kgc_1hb"" -->"
3;172;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;TAN;"- TAN(DOUBLE) => DOUBLE  
"
4;195;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;ADD_DAYS;"Computes the specified DATE or TIMESTAMP value, plus or minus the specified days. The value to be added or
subtracted needs to be an INTEGER.  
- ADD_DAYS(DATE, INTEGER) => DATE
- ADD_DAYS(TIMESTAMP, INTEGER) => TIMESTAMP  
"
5;88;60;20;70;060-020-070-Graph_Traversal_Statements.md;Graph Traversal Statements;Breadth-First Search (BFS);"BFS visits adjacent edges and vertices first before stepping deeper into the graph.
It supports two hook functions: ON VISIT VERTEX and ON VISIT EDGE which are executed when the
elements are visited the first time.  
Next to a single start vertex, BFS also supports multiple start vertices in form of a Multiset.
Any expression resulting in a Multiset of vertices is permitted, including ad hoc definitions with
curly braces shown in the next example.  
```graphscript
TRAVERSE BFS :g FROM { Vertex(:g, 1), Vertex(:g, 2) }
ON VISIT VERTEX (VERTEX v) {
...
};
```  
BFS is the only traversal algorithm which supports various traversal directions.
It is optionally passed as an argument to the BFS specifier.  
```graphscript
TRAVERSE BFS('INCOMING') :g FROM :startVertex
ON VISIT VERTEX (VERTEX v) {
...
};
```  
Please note the single quotes around the parameter INCOMING.
The direction parameter is of type string.
It can be either a reference to a string variable or a literal string value as shown here.  
Three string values are supported: OUTGOING which is the default, INCOMING and ANY.
OUTGOING follows the direction of edges from the source vertex to the target vertex.
INCOMING walks edges in the reverse direction from target to source.
ANY treats edges as undirected edges, ignoring the direction stored in the data."
6;234;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;DATETIME;"The DATETIME() function takes a string value in YYYY-MM-DD HH24:MI:SS.FF7 format and converts it to
a datetime value with year, month, day, hour, minute, seconds and fractional seconds component
values.  
```bnf
<datetime_function> ::= DATETIME '(' <variable_name> '.' <attribute_name> ')'
```  
DATETIME(NULL) returns NULL. An error is thrown if the parsing fails.  
<!--! section id=""_"" -->"
7;130;60;50;30;060-050-030-Typed_Literals.md;Typed Literals;;"A literal is a symbol that represents a specific fixed data value.  
"
8;115;60;40;0;060-040-000-Table_Operations.md;Table Operations;Projection Expression;"A shorthand notation to convert data in a container to a tabular format is provided by the
projection expression. The result must be assigned to a table variable with a compatible column
layout, i.e., the type of first column must be compatible to the type of the first element in the
projection list, and so on. The assignment of projection list elements to result table columns is
done by position. Note that old content of the table variable gets replaced by the new
content of the projection.  
The projection expression starts with the SELECT keyword, followed by the projection list and the
FOREACH notation used in [FOREACH loops](loio72955c729448436ab8269192b71fb495/FOREACH Loops).
The projection list is a comma-separated list of expressions. For example,
these expressions can be an access to attributes of a vertex variable or a lookup into a
Sequence or Map container with a scalar variable as positional index or key value.  
```bnf
<projection_expr> ::= SELECT <proj_list> FOREACH <variable> IN <expr> [WITH ORDINALITY AS <variable>]
| SELECT <proj_list> FOREACH ( <variable> , <variable> ) IN <expr>
<proj_list> ::= <proj> [, <proj_list>]
<proj> ::= <expr>
```  
The projection expression may iterate over containers or maps.  
```graphscript
MULTISET<VERTEX> myVertices = ...;
-- projecting vertex attributes
myTable1 = SELECT :v.""NAME"", :v.visited FOREACH v IN :myVertices;  
SEQUENCE<EDGE> edgeSequence = ...;
-- projecting one edge attribute and the position of the edge in the sequence
myTable2 = SELECT :e.""NAME"", :i FOREACH e IN :edgeSequence WITH ORDINALITY AS i;  
MAP<VERTEX,DOUBLE> costMap = ...;
-- projecting vertices in a map and associated values, cost in map and vertex attributes
myTable3 = SELECT :v.""NAME"", :cost FOREACH (v,cost) IN :costMap;
```  
<!--! note -->
### Note  
- Tables or table types are permitted for IN and OUT parameters.  
<!--! end-note -->  

### Examples  
```sql
CREATE TYPE tt AS TABLE(NAME NVARCHAR, ATTR INTEGER);  
CREATE PROCEDURE myTableProc (IN i_tab tt, OUT o_tab tt)
LANGUAGE GRAPH READS SQL DATA AS
BEGIN
INTEGER i = :i_tab.attr[1L];
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(VERTEX INTEGER ATTR = :i);
o_tab = SELECT :v.""NAME"", :v.attr FOREACH v IN VERTICES(:g);
END;
```  
<!--! section id=""return_table_statement"" -->"
9;249;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;;"GraphScript is the imperative extension language of SAP HANA Graph.
It's designed to ease the development of application-specific graph algorithms
and to integrate them into the overall data processing workflow.  
"
10;199;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;SECONDS_BETWEEN;"Computes the number of seconds between two specified TIMESTAMP values.  
- SECONDS_BETWEEN(TIMESTAMP, TIMESTAMP) => BIGINT  
"
11;25;60;5;0;060-005-000-Integration_into_Stored_Procs.md;Integration into the SAP HANA Environment;;"The GraphScript language can be used in the following HANA SQL logic containers:
Stored procedures, anonymous blocks, and table user-defined functions.
Logic containers with GraphScript code support only a subset of the options
and data types supported by SQLScript. Besides these differences, logic containers
with GraphScript code can be created, dropped and used in the very same way as
logic containers with SQLScript code.  
<!--! section id=""GraphScript_Procedure""-->"
12;45;60;20;20;060-020-020-Basic_Graph_Operations.md;Basic Graph Operations;Temporary Attribute Definition;"A temporary attribute can be used to store vertex-centric or edge-centric state information at
script runtime. Read access to temporary attributes is the same as for persistent attributes; write
access is only allowed for temporary attributes.  
You can specify temporary attributes only during creation of the graph object. If you expect a temporary attribute
to be set for more than 10-15% of vertices or edges add the DENSE keyword to the specification. The DENSE keyword allows
the compiler to use a more efficient implementation for more frequently used attributes.  
```bnf
<graph_function> ::= GRAPH '('
<edge_table_variable>,
<source_column_identifier>,
<target_column_identifier>,
<edge_id_column_identifier>,
<vertex_table_variable>,
<vertex_id_column_identifier> ')'
WITH TEMPORARY ATTRIBUTES '(' <attr_list> ')'  
<attr_list> ::= <attr_spec> | <attr_list> , <attr_spec>
<attr_spec> ::= <vertex_or_edge> <primitive_type> <identifier> [ = <expr> ] [ DENSE ]
```  

### Examples  
```graphscript
GRAPH g1 = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(VERTEX INTEGER distance = 0, EDGE DOUBLE price = 0.0);
GRAPH g2 = GRAPH(""ROADS"", ""NETWORK"")
WITH TEMPORARY ATTRIBUTES(VERTEX INTEGER typeId DENSE);
```"
13;221;70;20;10;070-020-010-Match_Clause.md;MATCH Clause;;"The MATCH clause consists of topological constraints that define the topology (vertices, edges, and
paths) of the matching subgraphs, and an optional filter condition, which allows the user to add
additional (non-topological) constraints. These constraints must be fulfilled by each match in the
graph workspace to become a part of the result.  
```bnf
<match_clause> ::= MATCH <topology_constraints>
[WHERE <non_topology_constraints>]
<topology_constraints> ::= <topology_constraint>
[{<comma> <topology_constraint>}]
```  
<!--! section id=""section_e3p_2yg_4bb"" -->"
14;75;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;MODULARITY;"```bnf
<community_function> ::= MODULARITY â€˜(' <graph>,<communities>[,< weight>]')'
```
This function computes the modularity of communities that partition a graph.
The return value is DOUBLE.
Modularity is a quality metric for communities that quantifies if there are many edges inside communities and fewer between them.  
### Parameter
graph: Graph where the community is derived from  
communities: Communities that partition <graph> in the form of SEQUENCE<MULTISET<VERTEX>>  
weight: Function that provide an edge weight for each edge in the graph (Default: (Edge e) => DOUBLE{ return 1.0; })  
### Examples  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");  
SEQUENCE<MULTISET<VERTEX>> communities = [â€¦]
DOUBLE metric = MODULARITY(:g, :communities, (Edge e) => DOUBLE{ return 1.0; })
```  
"
15;99;60;30;20;060-030-020-Sequence.md;SEQUENCE;Constructors;"SEQUENCE variables can be initialized with a comma-separated enumeration of elements within square
brackets.  
```bnf
<sequence_init_expr> ::= '[' <initializer_list> ']'
<initializer_list> ::= <expr> | <initializer_list> , <expr>
```  
```graphscript
NVARCHAR b = 'blue';
SEQUENCE<NVARCHAR> s1 = [ 'red', 'green', :b ];
SEQUENCE<SEQUENCE<NVARCHAR>> s2 = [:s1, ['yellow', :b]];
```  
By default, a sequence of a primitive type is initialized as empty.  
```graphscript
SEQUENCE<DOUBLE> s3;
SEQUENCE<SEQUENCE<DOUBLE>> s4;
```  
An empty sequence of a primitive type can also be initialized explicitly with the sequence
constructor.  
```graphscript
SEQUENCE<BIGINT> s5 = SEQUENCE<BIGINT>();
SEQUENCE<SEQUENCE<BIGINT>> s6 = SEQUENCE<SEQUENCE<BIGINT>>();
```  
An empty sequence of VERTEX or EDGE type requires a graph variable for initialization.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
SEQUENCE<VERTEX> s7(:g);
SEQUENCE<SEQUENCE<VERTEX>> s8(:g);
```  
Additionally, a sequence can be initialized by an operation or function returning a sequence.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
SEQUENCE<VERTEX> sv = SEQUENCE<VERTEX>(VERTICES(:g));
```  
"
16;87;60;20;70;060-020-070-Graph_Traversal_Statements.md;Graph Traversal Statements;;"Many advanced graph algorithms are built on top of basic graph algorithms, extending them with a bit
of custom code at specific points during the execution.
For this exact purpose, GraphScript provides the TRAVERSE statement.
It is an expressive way to describe algorithm variations with a set of well-defined extension
points.
Basic traversal algorithms like breadth-first search (BFS), depth-first search (DFS) and Dijkstra's
algorithm can be extended with so-called hook functions.
They are executed when specific events happen during the traversal, for example, a vertex or an
edge is visited for the first time.  
The following example illustrates the basic structure of the statement.
It calculates the vertex preorder and postorder in a DFS started from a single vertex.  
```graphscript
GRAPH g = GRAPH(""EXAMPLE"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES (
VERTEX INTEGER preorder = -1,
VERTEX INTEGER postorder = -1
);
INTEGER pre = 1;
INTEGER post = 1;
VERTEX startVertex(:g, 1);  
TRAVERSE DFS :g FROM :startVertex
ON VISIT VERTEX (VERTEX v) {
v.preorder = :pre;
pre = :pre + 1;
}
ON EXIT VERTEX (VERTEX v) {
v.postorder = :post;
post = :post + 1;
};
```  
First, there is some setup code to declare a graph with two temporary vertex attributes and two
counters for the preorder and postorder.
The TRAVERSE keyword starts the traversal statement, followed by a specifier identifying the basic
traversal algorithm, DFS in this case.
The supported specifiers are BFS, DFS and DIJKSTRA.
Next, the graph is referenced on which the traversal will run.
The header line is completed by the keyword FROM and the start vertex description, which accepts
any expression resulting in a vertex of the referenced graph.  
After the header follows a list of clauses defining the extensions to the basic traversal.
Here, two hook functions are defined: one for the preorder calculation using ON VISIT VERTEX and
a second one for the postorder calculation using ON EXIT VERTEX.
The VISIT VERTEX hook is executed when a vertex is reached the first time.
Similarly, the EXIT VERTEX hook is executed right before the DFS backtracks from the vertex.
ON EXIT VERTEX is only available in DFS as the other algorithms do not backtrack.  
The next sections describe the available extension points for each supported traversal algorithm."
17;227;70;20;30;070-020-030-Keywords.md;Keywords;Reserved Keywords;"|   |   |   |   |   |
|----|----|----|----|----|
|optional|distinct|unique|detach|union|
|unwind|merge|create|set|delete|
|remove|on|ascending|descending|xor|
|null|true|false|case|when|
|then|else|end|foreach|call|
|constraint|assert|load|csv|headers|
|fieldterminator|index|yield|using|drop|
|profile|explain|start|is| |  
<!--! section id=""section_cgr_s2d_wbb"" -->"
18;42;60;20;20;060-020-020-Basic_Graph_Operations.md;Basic Graph Operations;Constructors;"Creates a graph object. Two different variations are available:  
```bnf
<graph_function> ::= GRAPH '(' <schema_name>, <workspace_name> ')'
<schema_name> ::= <identifier>
<workspace_name> ::= <identifier>
```  
Creates a graph object based on the specified workspace in the specified schema.
If the schema parameter is omitted, then the SQL schema inference rules apply.  
```bnf
<graph_function> ::= GRAPH '('
<edge_table_variable>,
<source_column_identifier>,
<target_column_identifier>,
<edge_id_column_identifier>,
<vertex_table_variable>,
<vertex_id_column_identifier> ')'  
<edge_table_variable> ::= <variable_reference>
<source_column_identifier> ::= <identifier>
<target_column_identifier> ::= <identifier>
<edge_id_column_identifier> ::= <identifier>
<vertex_table_variable> ::= <variable_reference>
<vertex_id_column_identifier> ::= <identifier>
```  
Creates a graph object based on the specified edge and vertex tables, which are passed as arguments
to the GraphScript procedure. Besides the edge and vertex
table variables, the column identifiers of edge source, edge target, edge key, and vertex key need
to be specified.  

### Examples  
```graphscript
GRAPH g1 = GRAPH(""FLIGHTS"", ""GRAPH"");
```  
```sql
CREATE TYPE flightsEdgeType AS TABLE(
edge_key BIGINT,
source NVARCHAR(100),
target NVARCHAR(100),
dist_km DOUBLE
);
CREATE TYPE flightsVertexType AS TABLE(
node_key NVARCHAR(100),
name NVARCHAR(100)
);  
CREATE PROCEDURE graph_from_tabular_input (
IN i_edges flightsEdgeType, IN i_vertices flightsVertexType)
LANGUAGE GRAPH READS SQL DATA AS
BEGIN
GRAPH tmp_graph = GRAPH(:i_edges, ""SOURCE"", ""TARGET"", ""EDGE_KEY"", :i_vertices, ""NODE_KEY"");
-- ...
END;
```  
"
19;261;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Relational Expression;"```graphscript
2 < 3
3 == 4
:a.weight >= 5
:v.attr != 'blue'
```  
"
20;225;70;20;30;070-020-030-Keywords.md;Keywords;;"All keywords are case insensitive.  
<!--! section id=""section_uzv_n2d_wbb"" -->"
21;252;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Graph Types;"```graphscript
GRAPH g1 = GRAPH(""my_graph_workspace"");
GRAPH g2 = GRAPH(""my_schema"", ""workspace"");
```  
Defines a graph based on a workspace catalog object.  
```graphscript
GRAPH g3 = GRAPH(:edgeTab, ""srcCol"", ""tgtCol"",
""edgeIdCol"", :vtxTab, ""vtxIdCol"");
```  
Defines a graph based on edge and vertex tables.  
"
22;100;60;30;20;060-030-020-Sequence.md;SEQUENCE;Functions;"
### COUNT  
Returns the size of the given sequence. The result type is BIGINT.  
```graphscript
SEQUENCE<BIGINT> s9 = [1L, 2L, 3L];
BIGINT s9count = COUNT(:s9); -- s9count is 3L  
SEQUENCE<SEQUENCE<BIGINT>> s10 = [[1L, 2L], [3L, 4L, 5L]];
BIGINT s10count = COUNT(:s10); -- s10count is 2L
```  

### IS_EMPTY  
Returns true if the sequence has no elements.  
```graphscript
SEQUENCE<DOUBLE> nonEmptySeq = [0.0, 0.1, 0.2];
BOOL b1 = IS_EMPTY(:nonEmptySeq); -- b1 is FALSE  
SEQUENCE<DOUBLE> emptySeq;
BOOL b2 = IS_EMPTY(:emptySeq); -- b2 is TRUE  
```  

### MULTISET  
Returns a multiset containing elements from the given sequence. The order of elements is lost.  
```graphscript
SEQUENCE<NVARCHAR> scolors = ['red', 'green', 'blue'];
MULTISET<NVARCHAR> mcolors = MULTISET<NVARCHAR>(:scolors); -- mcolors is {'green', 'blue', 'red'}
```  
When initializing a new variable of type MULTISET, a shorthand notation can be used.  
```graphscript
MULTISET<NVARCHAR> mshort(:scolors); -- same as mcolors
```  

### RANDOM_ELEMENT  
Returns a randomly chosen element from the given sequence.  
```graphscript
INT random_int = RANDOM_ELEMENT([1,2,3]);
SEQUENCE<NVARCHAR> seq = ['a','b','c'];
NVARCHAR random_char = RANDOM_ELEMENT(:seq);
```  

### TO_ORDINALITY_MAP
This function converts a SEQUENCE of SEQUENCE of VERTEX or EDGE to a
MAP with VERTEX or EDGE as the key and a BIGINT as the value. It
places the vertices or edges as keys in the MAP with the ordinalities of
the SEQUENCEs, where they are located, as values. Keys that appear
multiple times will be ignored after they have been discovered the
first time.  
```graphscript
SEQUENCE<SEQUENCE<VERTEX>> groupSeq  = [[:v3, :v1, :v3], [:v2]];
MAP<VERTEX, BIGINT> ordMap = TO_ORDINALITY_MAP(:groupSeq);
:mapCommunities1[:v1] == 0L; -- true
:mapCommunities1[:v2] == 1L; -- true
:mapCommunities1[:v3] == 0L; -- true
``  
"
23;80;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Subgraph;"Constructs a subgraph of a graph based on a set of vertices or edges.  
```bnf
<subgraph_function> ::= SUBGRAPH '(' <parent_graph_variable>, <container_of_vertices> ')'
<parent_graph_variable> ::= <variable_reference>
<container_of_vertices> ::= <expr>
```  
Returns the subgraph of the given parent graph induced by the given container of vertices. The
subgraph contains a copy of all vertices in the input vertex container as well as all edges of the
parent graph whose source and target are both in the given vertex container.  
```bnf
<subgraph_function> ::= SUBGRAPH '(' <parent_graph_variable>, <container_of_edges> ')'
<parent_graph_variable> ::= <variable_reference>
<container_of_edges> ::= <expr>
```  
Returns the subgraph of the given parent graph induced by the given container of edges. The subgraph
contains the given edges as well as all source and target vertices of the given edge
container.  
A subgraph is a view on the parent graph, so all vertices and edges of a subgraph are the same
than the vertices and edges of the parent graph. Modifications of temporary attributes in the parent graph are
visible on the subgraph and vice versa.  

### Examples  
The following example demonstrates the usage of the subgraph function in combination with temporary
attributes. The temporary attribute `continent` is defined on graph `g_flights` before deriving the
subgraph `g_EuropeanFlights` from `g_flights` and can also be accessed for a vertex of `g_EuropeanFlights`.  
```graphscript
GRAPH g_flights = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(VERTEX NVARCHAR continent);
-- read continents of nodes from input table...
GRAPH g_EuropeanFlights = SUBGRAPH(
:g_flights, v IN VERTICES(:g_flights) WHERE :v.continent == 'Europe');  
VERTEX v_amsterdamEUR(:g_EuropeanFlights, 'AMS');
v_amsterdamEUR.continent = 'Europe';  
VERTEX v_amsterdam(:g_flights, 'AMS');
NVARCHAR cnt = :v_amsterdam.continent;
--> cnt is 'Europe'
```  
"
24;173;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;TANH;"- TANH(DOUBLE) => DOUBLE  
"
25;254;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Vertex and Edge Types;"```graphscript
VERTEX v1(:g, 1);
EDGE e1(:g, 2, 'keyVal2');     -- edge constructor with composite key
VERTEX v2(:path, 'label', 3);  -- vertex constructor with label
```  
Constructs vertex and edge references from a graph or a weighted path, and a (composite) key. For
graphs with multiple vertex or edge tables, a vertex or edge label is necessary in the constructor.  
"
26;125;60;50;20;060-050-020-Non-Numeric_Scalar_Types.md;Non-Numeric Scalar Types;Boolean Type;"The BOOLEAN data type stores Boolean values, which are TRUE and FALSE.
A variable of type BOOLEAN is default-initialized with value NULL.  
"
27;253;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Temporary Attributes;"```graphscript
GRAPH g3 = GRAPH(""my_schema"", ""workspace"")
WITH TEMPORARY ATTRIBUTES(EDGE INTEGER attr = 2 * 1,
VERTEX DOUBLE otherattr DENSE);  
Defines a graph with additional temporary attributes.
```  
"
28;43;60;20;20;060-020-020-Basic_Graph_Operations.md;Basic Graph Operations;VERTICES;"Returns all vertices in a graph.  
- VERTICES(GRAPH) => MULTISET  
"
29;169;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;SIN;"- SIN(DOUBLE) => DOUBLE  
"
30;30;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;Grammar;"In general, GraphScript's grammar consists of three different fundamental types of constructs:  
- Statements: self-containing language constructs that can have side effects
- Expressions: language constructs that return a value of a given type
- Terminal symbols: special characters and symbols  

### Statements  
A GraphScript program consists of an arbitrary number of statements.  
```bnf
<script> ::= <statements>
<statements> ::= { <statement> }
```  
The following types of statements are supported in GraphScript:  
```bnf
<statement> ::=
<definition>
| <assignment>
| <conditional>
| <foreach_loop>
| <return_table_statement>
| <temp_attribute>
| <while_loop>
| <traversal>
| <end_traversal>
```  

### Expressions  
An expression is a language construct that returns a value of a given type.  
```bnf
<expr> ::=
<literal_expr>
| <attr_access_expr>
| <local_var_expr>
| <arithmetic_expr>
| <relational_expr>
| <logical_expr>
| <collection_init_expr>
| <function_expr>
| <set_operation>
| <concat_expr>
| <index_expr>
| <cell_expr>
| <filter_expr>
| <proj_expr>
| <clos_expr>
| <order_expr>
```  
GraphScript supports the following expressions:  
- Literal expressions (`literal_expr`)
- Attribute access expressions (`attr_access_expr`)
- Local variable expressions (`local_var_expr`)
- Arithmetic expressions (`arithmetic_expr`)
- Relational expressions (`relational_expr`)
- Logical expressions (`logical_expr`)
- Collection initializer list expressions (`collection_init_expr`)
- Function expressions (`function_expr`)
- Set operations (`set_operation`)
- Concatenation expressions (`concat_expr`)
- Positional access expressions (`index_expr`)
- Cell access expressions (`cell_expr`)
- Filter expressions (`filter_expr`)
- Projection expressions (`proj_expr`)
- Closure expressions (`clos_expr`)
- Order expressions (`order_expr`)  

### Terminal Symbols  
The following list summarizes special characters and symbols that are used in GraphScript.  
```bnf
<comma> ::= ,
<single_quote> ::= '
<double_quote> ::= ""
<l_paren> ::= (
<r_paren> ::= )
<l_curly> ::= {
<r_curly> ::= }
<l_square> ::= [
<r_square> ::= ]
<pipe> ::= ||
<semicolon> ::= ;
<colon> ::= :
<dot> ::= .
<equals> ::= =
<minus> ::= -
<plus> ::= +
<lower> ::= <
<lower_equal> ::= <=
<greater> ::= >
<greater_equal> ::= >=
<leads_to> ::= =>
<equal> ::= ==
<unequal> ::= !=
<membership_in> ::= IN
<membership_not_in> ::= NOT IN
<underscore> ::= _
<asterisk> ::= *
<slash> ::= /
<modulo> ::= %
<circumflex> ::= ^
<any_character> ::= !! any character
<hash_symbol> ::= #
<dollar_sign> ::= $
<questionmark> ::= ?
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<pos_digit> ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q |
r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J |
K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
```  
"
31;196;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;ADD_MONTHS;"Computes the specified DATE or TIMESTAMP value, plus or minus the specified months. The value to be added or
subtracted needs to be an INTEGER.  
- ADD_MONTHS(DATE, INTEGER) => DATE
- ADD_MONTHS(TIMESTAMP, INTEGER) => TIMESTAMP  
"
32;56;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;Vertex Attribute Access;"An attribute access expression allows you to retrieve the corresponding attribute value for a given
vertex variable and attribute name. The attribute name is an identifier. The return type of the
expression is derived from the underlying specified attribute type.  
```bnf
<attr_access_expr> ::= <variable_reference> . <identifier>
```  

### Examples  
```graphscript
INTEGER cost = :v.cost;
NVARCHAR name = :v.""NAME"";
```"
33;91;60;20;70;060-020-070-Graph_Traversal_Statements.md;Graph Traversal Statements;Hook Functions;"The extension points to the graph traversal are so-called traversal hooks.
Closure expressions must be passed to the hooks which act as callbacks for well-defined events
during the traversal.  
Closures are small, unnamed functions which receive internal information of the traversal as
function parameters.
Additionally, they capture all variables from the scope of the TRAVERSE statement by reference.
This means that outside variables are available inside the hook functions for read and write
operations.  
```graphscript
BIGINT reachable_vertices = 0L;
TRAVERSE BFS :g FROM :startVertex
ON VISIT VERTEX (VERTEX v) {
reachable_vertices = :reachable_vertices + 1L;
};
```  
The first parameter of vertex hook functions is always the vertex where the event happened, even if
the parameter is unused inside the function.
It cannot be omitted in the parameter list.
Similarly, edge hooks always receive the current edge as first parameter.
Additional parameters are optional and depend on the particular traversal algorithm.  
BFS and DFS provide the number of hops as optional second parameter.
The parameter is of type BIGINT and contains the number of edges it took to reach the current vertex
or edge.
A third optional parameter of type BOOL is only available for the edge hook.
It describes if the edge is traversed in the direction of the edge (true value) or in the reverse
direction (false value).
This indicator is only relevant for BFS with traversal direction ANY.  
```graphscript
TRAVERSE BFS('ANY') :g FROM :startVertex
ON VISIT EDGE (EDGE e, BIGINT hops, BOOL forwards) {
e.""hops"" = :hops;
e.""forwards"" = :forwards;
};
```  
DIJKSTRA provides the accumulated weight as second optional parameter and the number of hops as
third one.
Both parameters calculate the distance from the start vertex along the shortest path, either by
accumulating the weight of all edges (second parameter) or by counting the number of edges (third
parameter).
The accumulated weight has the same type as the weight type specified in the weight function.  
```graphscript
TRAVERSE DIJKSTRA :g FROM :startVertex
WITH WEIGHT (EDGE e) => DOUBLE {
return :e.""weight"";
}
ON VISIT VERTEX (VERTEX v, DOUBLE distance, BIGINT hops) {
v.""distance"" = :distance;
v.""hops"" = :hops;
};
```  
The available traversal hooks differ slightly between traversal algorithms.
All graph traversals support the hooks ON VISIT VERTEX and ON VISIT EDGE, which are executed when
a vertex or an edge is visited the first time.
ON EXIT VERTEX is only supported by DFS and runs right before the algorithm backtracks from the
vertex.  
Furthermore, DIJKSTRA requires a weight function defined by WITH WEIGHT.
It is the only function which has a return value: the calculated weight for the passed edge.
The weight type must be specified after the parameter list, as shown in the example above.
Supported weight types are DOUBLE, INTEGER and BIGINT.  
There are two special statements, END TRAVERSE and END TRAVERSE ALL, which prune edges and vertices
from the search space.
A more detailed description follows in the next subsections.  
Hook functions allow the usage of return statements without an expression to leave the function body
early. Those can for instance be used in combination with END TRAVERSE or END TRAVERSE ALL
statements to not execute the subsequent instructions within the hook function.  
```graphscript
TRAVERSE DFS :g FROM :startVertex
ON VISIT VERTEX (VERTEX v) {
if (:v == Vertex(:g, 1)) {
END TRAVERSE ALL;
return;
}
-- Other statements, that should not be executed when the if statement evaluates to 'true'.
};
```  
### END TRAVERSE Statement  
The END TRAVERSE statement is only valid in a hook function or a weight function.
When executed, further exploration is stopped at the current vertex or edge, pruning the search
space.
In VISIT VERTEX, this means that the adjacent edges of the vertex are not visited.
Similarly in VISIT EDGE, the edge is not traversed and the adjacent vertex is not visited through
this edge.
Be aware that there might be other paths still visiting the adjacent vertices and edges.  
The following example illustrates how to avoid certain edges in a graph like toll roads by using
END TRAVERSE in a VISIT EDGE hook.  
```graphscript
TRAVERSE BFS :g FROM :startVertex
ON VISIT EDGE (EDGE e) {
if(:e.""type"" == 'toll road') {
END TRAVERSE;
}
}
ON VISIT VERTEX (VERTEX v, BIGINT hops) {
v.""hops"" = :hops;
};
```  
END TRAVERSE does not have any effect in EXIT VERTEX.
Use END TRAVERSE ALL to terminate the graph traversal.  
### END TRAVERSE ALL Statement  
END TRAVERSE ALL is another statement only valid in a traversal hook.
It terminates the graph traversal by discarding all elements for further exploration.
Use it as an early exit, e.g., stop exploring when the destination is found.  
```graphscript
TRAVERSE DIJKSTRA :g FROM :startVertex
WITH WEIGHT (EDGE e) => DOUBLE {
return :e.""weight"";
}
ON VISIT VERTEX (VERTEX v, DOUBLE distance) {
if(:v == :destination) {
dest_distance = :distance;
END TRAVERSE ALL;
}
};
```  
Please note that some other hook functions will run even after executing END TRAVERSE ALL.
In BFS, all vertex or edge hooks on the same level as the vertex or edge hook calling END TRAVERSE
ALL will be executed nonetheless.
In DFS, backtracking is still executed which means that the EXIT VERTEX hooks are still run for
already visited vertices."
34;215;70;10;0;070-010-000-OPENCYPHER_TABLE_SQL_Function.md;OPENCYPHER_TABLE SQL Function;;"The OPENCYPHER_TABLE SQL function enables the embedding of an openCypher query in an SQL query. The
result is returned as a table. The column names and types of the resulting table are determined by
both the [openCypher Query Language](loio5273f1dab0ef4d00bb7c67f5f2730649) and the
[Graph Workspaces](loio72e93671da4b49bda6cf6d7b08346c47).  
OPENCYPHER_TABLE is robust with respect to inconsistent graph workspaces.
Errors can occur in rare cases, but usually the inconsistent parts don't show in the result.  
<!--! section id=""section_rz2_z1n_xgb"" -->"
35;17;40;30;0;040-030-000-Export_and_Import_Graph_Workspaces.md;Export and Import Graph Workspaces;;"Graph workspace objects can be exported from or imported into an SAP HANA Cloud system using the
frontend tools in the same way as for exporting/importing views or tables."
36;104;60;30;30;060-030-030-Map.md;MAP;;"A map is an associative container that contains key-value-pairs with unique keys.  
The keys of a map can be of type VERTEX, EDGE or any scalar type except DOUBLE and BOOL. The keys
must not be NULL. Any scalar data type can be used to store the mapped values.  
During the construction, a default value can be specified. If no default value is specified, the
default is assumed NULL. The default value must have the same type as the type of the value. When
reading a map entry, if no value for the given key was stored beforehand, the default value is
returned.  
"
37;205;60;50;90;060-050-090-Boolean_Expressions.md;Boolean Expressions;Logical Expressions;"Logical expressions take two expressions and a logical operator and
produce a Boolean result value. Both expressions have to be of the same type.  
```bnf
<logical_expr> ::= <expr> <logical_op> <expr> | NOT '(' <expr> ')'
<logical_op> ::= AND | OR
```  

### Examples  
```graphscript
(3 == 4) AND (4 == 3)
TRUE OR (:e.WEIGHT > 3)
NOT (3 == 2)
```  
<!--! section id=""section_yf1_xj3_wy"" -->"
38;86;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Strongly Connected Components;"```bnf
<scc_function> ::= STRONGLY_CONNECTED_COMPONENTS '(' <parent_graph_variable> ')'
<parent_graph_variable> ::= <variable_reference>
```  
Returns a sequence of sequences of vertices, representing the strongly connected components in the
parent graph. The foreach loop statement can be used to iterate over the result and access the
individual components. Each strongly connected component is represented as a sequence of vertices
and can be used in the same way as any other sequence of vertices.  

### Examples  
The following example demonstrates the usage of the strongly connected components function. The
result of the function is a container of containers. The built-in function COUNT can be used to
determine the total number of strongly connected components in the result. One can iterate over the
result and use a temporary vertex attribute to store the component number to which the vertex
belongs.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(VERTEX INTEGER componentNumber);
SEQUENCE<SEQUENCE<VERTEX>> sccResult = STRONGLY_CONNECTED_COMPONENTS(:g);  
BIGINT numComponents = COUNT(:sccResult);
INTEGER componentCounter = 0;
FOREACH component IN :sccResult {
componentCounter = :componentCounter + 1;
FOREACH v IN :component {
v.componentNumber = :componentCounter;
}
}
```"
39;164;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;RAND;"- RAND() => DOUBLE  
"
40;140;60;50;40;060-050-040-Type_Casts.md;Type Casts;NVARCHAR;"Casts an INTEGER, BIGINT, or DOUBLE value to a NVARCHAR value.  
- NVARCHAR(NVARCHAR) => NVARCHAR
- NVARCHAR(INTEGER) => NVARCHAR
- NVARCHAR(BIGINT) => NVARCHAR
- NVARCHAR(DOUBLE) => NVARCHAR  
It is also possible to provide a second argument having type NVARCHAR.  
- NVARCHAR(NVARCHAR,NVARCHAR) => Returns first argument as long it is not NULL, else it returns the second
argument.
- NVARCHAR(INTEGER,NVARCHAR) => Type casts INTEGER to NVARCHAR. If NULL, it returns the second argument.
- NVARCHAR(BIGINT,NVARCHAR) => Type casts BIGINT to NVARCHAR. If NULL, it returns the second argument.
- NVARCHAR(DOUBLE,NVARCHAR) => Type casts DOUBLE to NVARCHAR. If NULL, it returns the second argument.  
```graphscript
NVARCHAR var1 = NVARCHAR(3.2, 'bc'); -- var1 is '3.2'
NVARCHAR var2 = NULL;
var1 = NVARCHAR(:var2, 'b'); -- var1 is 'b'
```  
"
41;278;90;50;0;090-050-000-Appendix_D_-_OpenCypher_Cheat_Sheet.md;Appendix C - openCypher Cheat Sheet;MATCH clause;"Consists of topological constraints that define the topology (vertices, edges, and paths) of the
matching subgraphs, and an optional filter condition, which allows the user to add
additional (non-topological) constraints.  

### Topological Constraints  
```OpenCypher
MATCH (a)                                   -- any vertex
MATCH (a:label)                             -- vertex with label
MATCH (a)-[e]-(b)                           -- any edge between two vertices
MATCH (a)-[e]->(b)                          -- directed edge
MATCH (a)-[e]-(b:vertex_label)              -- edge with label for one vertex
MATCH (a:vertex_label)-[e:edge_label]->(b)  -- directed edge with label for edge and one vertex
MATCH p = (a)-[*1..2]->(b)                  -- variable-length path
MATCH p = (a)-[:edge_label*3..5]->(b)       -- variable-length path with edge label
```  
```OpenCypher
MATCH (a)-[e1]->(b)
MATCH (b)-[e2]->(c)
```  
Multiple match clauses form different patterns. The final result is a combination of results of each
individual pattern.  
```OpenCypher
MATCH (a)-[e1]->(b), (b)-[e2]->(c)
```  
Comma separated match clauses are part of the same pattern. Each relationship appears only once in
the result.  

### Non-Topological Constraints  
```OpenCypher
WHERE a.NAME = ''John F Kennedy International Airport''
AND (e.EDGE_KEY > 4 OR b.NAME = ''Philadelphia International Airport'')
```  
Adds constraints to the patterns using comparisons (=, <>, >, <, >=, <=), IS NULL, and other
boolean built-in functions, combined by the logical connectives AND, OR, and NOT.  
"
42;160;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;EXP;"- EXP(DOUBLE) => DOUBLE  
"
43;178;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;CURRENT_DATE;"Returns the current local system DATE value.
This function is an analogue to the homonymous function in HANA SQL.  
- CURRENT_DATE() => DATE  
"
44;35;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;Identifiers;"GraphScript uses identifiers to reference schema names, graph workspace names, and attribute names.
Similar to SQL, identifiers are case-sensitive when enclosed by double quotes, and case-insensitive
when used without double quotes. Best practice is to always use double quotes.  
Identifiers may look like literal values of type NVARCHAR, but they use double quotes instead of
single quotes. The two data types are not interchangeable.  
```bnf
<simple_identifier> ::= ( <letter> | <underscore> ) { <letter> | <underscore> |
<digit> | <hash_symbol> | <dollar_sign> }
<quoted_identifier> ::= <double_quote> { <any_charater> } <double_quote>
<identifier> ::= <simple_identifier> | <quoted_identifier>
```  
"
45;90;60;20;70;060-020-070-Graph_Traversal_Statements.md;Graph Traversal Statements;Dijkstra's Algorithm (DIJKSTRA);"DIJKSTRA searches for shortest paths in a weighted graph.
Vertices are visited in ascending order of their shortest distance from the start vertex.
In order to calculate the weight of each edge, a mandatory WITH WEIGHT clause must be provided.
The following example stores the shortest distance of each visited vertex in a temporary vertex
attribute, similar to the built-in function SHORTEST\_PATHS\_ONE\_TO\_ALL.  
```graphscript
TRAVERSE DIJKSTRA :g FROM :startVertex
WITH WEIGHT (EDGE e) => DOUBLE {
return :e.""weight"";
}
ON VISIT VERTEX (VERTEX v, DOUBLE distance) {
v.""distance"" = :distance;
};
```  
The weight function defined by WITH WEIGHT calculates the weight of the edge e, which is passed as a
parameter and returns the weight value with a return statement.
In the example, an edge attribute is directly used as the edge weight, but more complex calculations
are also possible.
The data type of the weight must be specified after the parameter list, following an arrow.
Supported weight types are DOUBLE, INTEGER and BIGINT.  
The vertex hook after ON VISIT VERTEX uses an optional second parameter after the visited vertex.
It contains the accumulated weight of the shortest path from the start vertex to the visited vertex
and has the same data type as specified in the weight function.
The next section describes in more detail the various signatures of the hook functions.  
The start vertex has to be a single vertex.
DIJKSTRA supports the traversal directions OUTGOING, INCOMING, and ANY.
The traversal direction is optionally passed as an argument to the DIJKSTRA specifier (e.g. TRAVERSE DIJKSTRA('ANY') :g). The default value is OUTGOING.  
DIJKSTRA is currently the only algorithm to support the collection of walked paths.
This enables the extraction of shortest paths from the start vertex to any visited vertex.
The following example code illustrates how to search for the k-nearest neighbors on a weighted
graph and extract the shortest path to each neighbor.
The example searches for the three closest gas stations.  
```graphscript
MAP<VERTEX,DOUBLE> stations(:g, 1024L);
-- declare result variable
TRAVERSERESULT<DOUBLE> shortest_path_tree(:g);  
TRAVERSE DIJKSTRA :g FROM :startVertex
WITH RESULT :shortest_path_tree -- pass to traversal
WITH WEIGHT (EDGE e) => DOUBLE {
return :e.""weight"";
}
ON VISIT VERTEX (VERTEX v, DOUBLE distance) {
if (:v.""TYPE"" == 'Gas station') {
stations[:v] = :distance;
if (Count(:stations) == 3L) { -- end traversal when three found
END TRAVERSE ALL;
}
}
};  
FOREACH (station,distance) IN :stations {
-- extract path from start vertex to each gas station
WEIGHTEDPATH<DOUBLE> p = GET_PATH(:shortest_path_tree, :station);
...
}
```  
First, a variable of type TRAVERSERESULT must be declared before the TRAVERSE DIJKSTRA statement.
Note that it must use the same weight type as TRAVERSE DIJKSTRA.
Next, the variable is passed to TRAVERSE by using the WITH RESULT clause.
Finally, shortest paths to any visited vertex can be constructed after the TRAVERSE statement by
calling the GET\_PATH built-in function with the result variable and the destination vertex."
46;170;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;SINH;"- SINH(DOUBLE) => DOUBLE  
"
47;197;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;ADD_YEARS;"Computes the specified DATE or TIMESTAMP value, plus or minus the specified years. The value to be added or
subtracted needs to be an INTEGER.  
- ADD_YEARS(DATE, INTEGER) => DATE
- ADD_YEARS(TIMESTAMP, INTEGER) => TIMESTAMP  
"
48;238;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;LABEL;"The LABEL function takes a vertex or an edge variable and returns the label of that variable.
If no label is specified for the vertex or edge table in the graph workspace, then the name of the
table is returned.  
```bnf
<label_function> ::= LABEL '(' <variable_name> ')'
```  
The following query illustrates the use of label function on a vertex variable of the heterogenous
graph `COMPANY_GRAPH`:  
```OpenCypher
MATCH (v)
WHERE v.NAME = ''SAP HANA Cloud''
RETURN LABEL(v) as Label
```  
|Label|
|---|
|Product|  
The following query illustrates the use of label function on an edge variable of the heterogenous
graph `COMPANY_GRAPH`:  
```OpenCypher
MATCH (v1:Project)-[e]-(v2:Employee)
WHERE v1.NAME = ''HANA'' OR v1.NAME = ''DWC''
RETURN v1.NAME as Project_Name, LABEL(e) as Label, v2.FIRST_NAME AS Employee_Name
ORDER BY v1.NAME
```  
|Project_Name|Label|Employee_Name|
|---|---|---|
|DWC|Assignments|Maria|
|DWC|Assignments|John|
|HANA|Assignments|Paul|
|HANA|Assignments|John|  
<!--! section id=""section_hyc_sl4_4bb"" -->"
49;121;60;50;10;060-050-010-Numeric_Types.md;Numeric Types;BIGINT;"The BIGINT data type specifies a 64-bit signed integer.  
- The minimum value is -9,223,372,036,854,775,808.
- The maximum value is 9,223,372,036,854,775,807.
- Literal values of type BIGINT have to be suffixed with an 'L'.
- A variable of type BIGINT is default-initialized with the value NULL.  
"
50;182;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;TIMESTAMP;"Creates a TIMESTAMP value from the given character string.
Throws a conversion error if the character string isn't a valid TIMESTAMP value.  
- TIMESTAMP(NVARCHAR) => TIMESTAMP  
"
51;102;60;30;20;060-030-020-Sequence.md;SEQUENCE;Filter Expressions;"A filter expression evaluates a predicate for each element of an input container. The matching
elements are returned as a multiset. Within the WHERE clause of the filter expression, it is
possible to access temporary variables, and temporary and non-temporary attributes of vertices and
edges, to use built-in functions, and to call functions. For filter expressions on sequence
containers, an optional ordinal variable can be used to access the ordinal position of the element
currently being processed.
In case of sequences it is possible to sort the result by specified attributes with an optional
direction.  
```
<filter_expr> ::= <variable> IN <expr> [ WITH ORDINALITY AS <variable> ]
WHERE <expr>
```  

### Examples  
```
v IN [ Vertex(:g, 1), Vertex(:g, 2) ] WITH ORDINALITY AS i WHERE :i > 2L;
```  
"
52;271;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Tables;"
### Operations  
```graphscript
INTEGER i = :tab.""colInt""[1L]; -- read
tab.""colInt""[1L] = 23; -- write
SEQUENCE<INTEGER> s3(:tab.""colInt""); -- sequence from column
BIGINT sz = COUNT(:tab); -- row count
MAP<INTEGER, INTEGER> map1(:inTable.""colInt1"", :inTable.""colInt2""); -- map from two table columns  
```  
"
53;264;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Membership Expression;"```graphscript
:i IN :mset_int
:str NOT IN :mset_nvarchar
```  
"
54;70;60;20;50;060-020-050-Basic_Weighted_Path_Operations.md;Basic Weighted Path Operations;IS_EMPTY;"Tests whether the given path is empty, i.e., it has no vertices.
The SHORTEST_PATH function returns an empty path if no connection is found from start to target vertex.  
- IS_EMPTY(WEIGHTEDPATH<BIGINT>) => BOOL
- IS_EMPTY(WEIGHTEDPATH<INTEGER>) => BOOL
- IS_EMPTY(WEIGHTEDPATH<DOUBLE>) => BOOL"
55;139;60;50;40;060-050-040-Type_Casts.md;Type Casts;DOUBLE;"Casts an INTEGER or BIGINT value to a DOUBLE value.  
- DOUBLE(DOUBLE) => DOUBLE
- DOUBLE(INTEGER) => DOUBLE
- DOUBLE(BIGINT) => DOUBLE  
It is also possible to provide a second argument having type DOUBLE.  
- DOUBLE(DOUBLE,DOUBLE) => Returns first argument as long it is not NULL, else it returns the second argument.
- DOUBLE(INTEGER,DOUBLE) => Type casts INTEGER to DOUBLE. If it fails or is NULL, it returns the second argument.
- DOUBLE(BIGINT,DOUBLE) => Type casts BIGINT to DOUBLE. If it fails or is NULL, it returns the second argument.  
```graphscript
DOUBLE var1 = NULL;
DOUBLE var2 = DOUBLE(:var1, 3.5); -- var2 is 3.5
```  
"
56;257;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;WHILE Loop;"```graphscript
INTEGER i = 0;
WHILE (:i < 10) {
i = :i + 1;
}
```  
"
57;92;60;30;0;060-030-000-Container_Operations_and_Functions.md;Container Types and Operations;;"A container is a composite value comprising zero or more elements of the same type. Containers are
typically used for temporarily holding and processing intermediate results.  
GraphScript offers two container types: MULTISET and SEQUENCE. Both container types support the
following data types: VERTEX, EDGE, INTEGER, BIGINT, DOUBLE, TIMESTAMP, NVARCHAR, and BOOLEAN.
Furthermore, Graphscript supports nested multisets i.e. multiset of multisets, and nested sequences
i.e. sequence of sequences.  
The element type is a part of the type specification and is written in angular brackets after the
MULTISET or SEQUENCE keyword.  
```bnf
<multiset_type> ::=
MULTISET '<' <vertex_or_edge> '>'
| MULTISET '<' <primitive_type> '>'
| MULTISET '<' MULTISET '<vertex_or_edge>' '>'
| MULTISET '<' MULTISET '<primitive_type>' '>'  
<sequence_type> ::=
SEQUENCE '<' <vertex_or_edge> '>'
| SEQUENCE '<' <primitive_type> '>'
| SEQUENCE '<' <weightedpath> '>'
| SEQUENCE '<' SEQUENCE '<vertex_or_edge>' '>'
| SEQUENCE '<' SEQUENCE '<primitive_type>' '>'
```  
Both container types can be used in FOREACH statements, filter expressions, and projection
expressions. There are also container-specific element types and operations.  
Containers of vertices or edges can only store elements from a single graph.
Container variables can not be reassigned to containers with elements from another graph."
58;34;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;Assignments;"An assignment statement binds the result of an expression to a local variable.
Alternatively, if the left-hand side of the assignment statement is an attribute access expression,
the value of the right-hand side expression is assigned to the corresponding attribute.  
```bnf
<assignment> ::= <variable> = <expr> ;
| <variable> = NULL ;
| <variable> = <projection_expr> ;
| <attr_access_expr> = <expr> ;
```  
GraphScript is statically typed and the data type of the object that is bound to the variable canâ€™t
change during the lifetime of a single query run. Only variables of primitive types can be set to
NULL. All variables have to be initialized before they can be referenced or accessed in a
GraphScript expression.  

### Examples  
```graphscript
GRAPH g = GRAPH(""MYWORKSPACE"");
INTEGER i;
i = 23;
VERTEX v(:g,1);
v.attr = 23;
```  
"
59;65;60;20;50;060-020-050-Basic_Weighted_Path_Operations.md;Basic Weighted Path Operations;(Constructors);"WEIGHTEDPATH objects canâ€™t be constructed directly but are the result of several built-in graph
algorithms.  
"
60;39;60;20;0;060-020-000-Graph_Operations_and_Functions.md;Graph Primitive Types and Operations;;Types and operations that make up the domain-specific core of the GraphScript language.
61;148;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;ASIN;"- ASIN(DOUBLE) => DOUBLE  
"
62;73;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Betweenness Centrality;"Computes the betweenness centrality, which is a measure of centrality  based
on shortest paths.
The betweenness centrality is the number of shortest paths for every pair of vertices that pass
through an edge or vertex. Therefore vertices or edges which lie often on shortest paths
between other vertices will receive a high betweenness centrality value.  
```bnf
<vbc_function> ::= BETWEENNESS_CENTRALITY '(' <graph_variable> ')'
<weighted_vbc_function> ::= BETWEENNESS_CENTRALITY '(' <graph_variable> , <clos_expr> ')'  
<ebc_function> ::= BETWEENNESS_EDGE_CENTRALITY '(' <graph_variable> [ , <variable_reference> ]  ')'
<weighted_ebc_function> ::= BETWEENNESS_EDGE_CENTRALITY '(' <graph_variable>, <clos_expr> [ , <variable_reference> ] ')'  
<graph_variable> ::= <variable_reference>
<vertex_centrality_map> ::= <variable_reference>
```  
The betweenness centrality can be calculated for vertices with the function BETWEENNESS_CENTRALITY and for
edges with the function BETWEENNESS_EDGE_CENTRALITY. Both functions return a mapping of vertices or edges
to the corresponding centrality value. If no othfurtherer parameter is specified, they compute the
centrality based on unweighted shortest paths.  
If an optional weight function is passed to those function the centrality is based on weighted
shortest paths. The weight function requires an edge as input parameter and
returns the weight as a numeric value.  
The BETWEENNESS_EDGE_CENTRALITY function additionally provides an optional map parameter from vertices
to centrality values, which also stores vertex centrality values if both are needed.  

### Examples  
The following example demonstrates the usage for unweighted betweenness centrality for either edge
or vertex centrality  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");  
MAP<VERTEX, DOUBLE> airport_centrality = BETWEENNESS_CENTRALITY(:g);
MAP<EDGE, DOUBLE> valueable_connections = BETWEENNESS_EDGE_CENTRALITY(:g);
```  
In addition, the algorithm returns the centrality based on weighted shortest paths if a
weight function has been provided.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");  
MAP<VERTEX, DOUBLE> airport_centrality(:g, 0L);
MAP<EDGE, DOUBLE> valueable_connections = BETWEENNESS_EDGE_CENTRALITY(
:g, :airport_centrality);
```  
If the centrality of vertices and edges is needed, both can be computed in one
step by passing a reference to a vertex centrality map as the last argument in the
BETWEENNESS_EDGE_CENTRALITY call.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");  
MAP<VERTEX, DOUBLE> airport_centrality(:g, 0L);
MAP<EDGE, DOUBLE> valueable_connections = BETWEENNESS_EDGE_CENTRALITY(
:g, (EDGE e)=> INTEGER{ RETURN :e.""DIST_KM""; }, :airport_centrality);  
MAP<VERTEX, DOUBLE> weighted_airport_centrality(:g, 0L);
MAP<EDGE, DOUBLE> weighted_valueable_connections = BETWEENNESS_EDGE_CENTRALITY(
:g, :weighted_airport_centrality);
```  
"
63;147;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;ACOS;"- ACOS(DOUBLE) => DOUBLE  
"
64;220;70;20;0;070-020-000-openCypher_Query_Language.md;openCypher Query Language;;"An openCypher query searches for subgraphs that match the specification given in MATCH clauses and
returns a result table as specified in the RETURN clause.
If the graph workspace consists of multiple vertex or edge tables, then the query result may contain
columns, which are not present in all the vertex or edge tables, respectively.
Missing entries are filled with NULL values.  
```
<opencypher_query> ::= <match_clauses> <return_clause>  
<match_clauses> ::= <match_clause> [{match_clause}]
```  
The total number of MATCH clauses in one openCypher query is currently limited to five.
OpenCypher expressions can include vertex or edge attributes only of the following types:
INT, BIGINT, DOUBLE, NVARCHAR, DATE, and TIMESTAMP.
Vertex or edge attributes of other types can be used in the RETURN-clause, but not within
aggregation functions or other expressions."
65;47;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;Constructors;"Constructs a [vertex](loio2c67724259aa42879d871b289098e86c) reference from a graph or a weighted path, a label and a (composite) key. If
multiple vertex tables are defined in the graph workspace, it is mandatory to provide a label in the
vertex constructor. The label comes directly after the graph or path variable
and right before the key components (scalar_key_type) in the argument list of the VERTEX constructor.
If no vertex with the given key exists, then the program terminates with an error.
Use the VERTEX_EXISTS function to determine whether a vertex exists.  
- VERTEX(GRAPH, NVARCHAR, scalar_key_type[,scalar_key_type]) => VERTEX
- VERTEX(WEIGHTEDPATH, NVARCHAR, scalar_key_type[,scalar_key_type]) => VERTEX  
In the case that only a single vertex table is defined, the label can be omitted.  
- VERTEX(GRAPH, scalar_key_type[,scalar_key_type]) => VERTEX
- VERTEX(WEIGHTEDPATH, scalar_key_type[,scalar_key_type]) => VERTEX  
A special case is the construction of a vertex from a compatible vertex. Vertices are compatible if
their host graphs are defined in the same graph workspace, e.g., a weighted path, a subgraph and
an inversed graph are compatible with the graph they are constructed from, as they all share the
same graph workspace.  
- VERTEX(GRAPH, VERTEX) => VERTEX
- VERTEX(WEIGHTEDPATH, VERTEX) => VERTEX  
"
66;138;60;50;40;060-050-040-Type_Casts.md;Type Casts;BIGINT;"Casts an INTEGER or DOUBLE value to a BIGINT value.
Throws a conversion error in the event of value overflows or underflows.  
- BIGINT(BIGINT) => BIGINT
- BIGINT(INTEGER) => BIGINT
- BIGINT(DOUBLE) => BIGINT  
It is also possible to provide a second argument having type BIGINT.  
- BIGINT(BIGINT,BIGINT) => Returns the first argument as long it is not NULL, else it returns the second argument.
- BIGINT(INTEGER,BIGINT) => Type casts INTEGER to BIGINT. If it fails or is NULL, it returns the second argument.
- BIGINT(DOUBLE,BIGINT) => Type casts DOUBLE to BIGINT. If it fails or is NULL, it returns the second argument.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(VERTEX INTEGER cost = 10);
VERTEX v = VERTEX(:g, 'FRA');
BIGINT var1 = BIGINT(:v.cost, 2L); -- var1 is 10L
```  
"
67;29;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;;"The GraphScript grammar consists of basic language elements, supports variables, and provides options for specifying the control flow.  
"
68;211;60;70;0;060-070-000-Complex_GraphScript_Examples.md;Complex GraphScript Examples;GraphScript Procedure Example;"The following example depicts a more complex example of a GraphScript procedure.
It uses the Open Flights data set and computes the shortest path one-to-one between the airports of
Philadelphia and Jinan.  
```sql
CREATE TYPE ""FLIGHTS"".""TT_NODES_SPOO"" AS TABLE (""NODE_KEY"" NVARCHAR(100));
CREATE TYPE ""FLIGHTS"".""TT_EDGES_SPOO"" AS TABLE (
""EDGE_KEY"" BIGINT, ""SOURCE"" NVARCHAR(100), ""TARGET"" NVARCHAR(100));  
CREATE OR REPLACE PROCEDURE ""FLIGHTS"".""GS_SPOO""(
IN i_startNode NVARCHAR(100),         -- the ID of the start node
IN i_endNode NVARCHAR(100),         -- the ID of the end node
OUT o_path_length BIGINT,    -- the hop distance between start and end
OUT o_path_weight DOUBLE,    -- the path weight/cost based on the WEIGHT attribute
OUT o_nodes ""FLIGHTS"".""TT_NODES_SPOO"",
OUT o_edges ""FLIGHTS"".""TT_EDGES_SPOO""
)
LANGUAGE GRAPH READS SQL DATA AS
BEGIN
-- create an instance of the graph, referring to the graph workspace object
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
INTEGER quot = INTEGER(2.1);
-- create an instance of the start/end node
VERTEX v_start = Vertex(:g, :i_startNode);
VERTEX v_end = Vertex(:g, :i_endNode);
-- running shortest path using the WEIGHT column as cost
WeightedPath<DOUBLE> p_efrf = Shortest_Path(:g, :v_start, :v_end, (Edge e)
=> DOUBLE{ return :e.""DIST_KM""/800.0; });
-- project the results from the path
o_path_length = LENGTH(:p_efrf);
o_path_weight = WEIGHT(:p_efrf);
o_nodes = SELECT :v.""NODE_KEY"" FOREACH v IN Vertices(:p);
o_edges = SELECT :e.""EDGE_KEY"", :e.""SOURCE"", :e.""TARGET"" FOREACH e IN Edges(:p);
END;  
CALL ""FLIGHTS"".""GS_SPOO""(
i_startNode => 'PHL', i_endNode => 'TNA',
o_path_length => ?, o_path_weight => ?, o_nodes => ?, o_edges => ?);
```  
The following example uses the Open Flights data set and computes the 3 shortest paths between
Jinan and Philadelphia.  
```sql
CREATE TYPE ""FLIGHTS"".""TT_PATHS_TKSP"" AS TABLE (
""PATH_ID"" INT, ""PATH_LENGTH"" BIGINT, ""PATH_WEIGHT"" DOUBLE,
""EDGE_KEY"" BIGINT, ""EDGE_ORDER"" INT);  
CREATE OR REPLACE PROCEDURE ""FLIGHTS"".""GS_TKSP""(
IN i_startNode NVARCHAR(100),         -- the ID of the start node
IN i_endNode NVARCHAR(100),         -- the ID of the end node
IN i_k INT,                 -- the number of paths to be returned
OUT o_paths ""FLIGHTS"".""TT_PATHS_TKSP""
)
LANGUAGE GRAPH READS SQL DATA AS
BEGIN
-- create an instance of the graph, referring to the graph workspace object
GRAPH g = Graph(""FLIGHTS"", ""GRAPH"");
-- create an instance of the start/end node
VERTEX v_start = Vertex(:g, :i_startNode);
VERTEX v_end = Vertex(:g, :i_endNode);
-- running top k shortest paths using the WEIGHT column as cost
SEQUENCE<WeightedPath<DOUBLE>> s_paths = K_Shortest_Paths(
:g, :v_start, :v_end, :i_k, (Edge e) => DOUBLE{ return :e.""DIST_KM""; });
-- project result paths into a table
BIGINT currentResultRow = 1L;
FOREACH result_path IN (:s_paths) WITH ORDINALITY AS path_id {
FOREACH path_edge in EDGES(:result_path) WITH ORDINALITY AS edge_order {
o_paths.""PATH_ID""[:currentResultRow] = INTEGER(:path_id);
o_paths.""PATH_LENGTH""[:currentResultRow] = Length(:result_path);
o_paths.""PATH_WEIGHT""[:currentResultRow] = Weight(:result_path);
o_paths.""EDGE_KEY""[:currentResultRow] = :path_edge.""EDGE_KEY"";
o_paths.""EDGE_ORDER""[:currentResultRow] = INTEGER(:edge_order);
currentResultRow = :currentResultRow + 1L;
}
}
END;  
CALL ""FLIGHTS"".""GS_TKSP""(i_startNode => 'TNA', i_endNode => 'PHL', i_k => 3, o_paths => ?);
```  
<!--! section id=""section_anonymous_block_example"" -->"
69;154;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;BITOR;"- BITOR(INTEGER,INTEGER) => INTEGER
- BITOR(BIGINT,BIGINT) => BIGINT  
"
70;134;60;50;30;060-050-030-Typed_Literals.md;Typed Literals;Datetime Literals;"Timestamp literals correspond to timestamp constructors with a string literal as initializer.  

### Examples  
```graphscript
TIMESTAMP('2019-12-19 16:30:12.345')
```"
71;189;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;YEAR;"Extracts the year component from a DATE or TIMESTAMP value.  
- YEAR(DATE) => INTEGER
- YEAR(TIMESTAMP) => INTEGER  
"
72;279;90;50;0;090-050-000-Appendix_D_-_OpenCypher_Cheat_Sheet.md;Appendix C - openCypher Cheat Sheet;RETURN Clause;"
### DISTINCT  
```OpenCypher
RETURN DISTINCT a.NAME AS Name
```  
Eliminates duplicate rows from the result.  

### ORDER BY  
```OpenCypher
RETURN a.NAME AS name
ORDER BY a.NAME DESC
```  
Sorts the resulting rows in ascending or descending order.  

### LIMIT  
```OpenCypher
RETURN a.NAME AS name
LIMIT 5
```  
Truncates the resulting table to the given number of rows.  

### SKIP  
```OpenCypher
RETURN a.NAME AS name
SKIP 2
```  
Excludes the given number of rows from the top of the result.  

### Aggregate functions  
```OpenCypher
RETURN COUNT(a.NAME) AS numCount    -- returns the number of rows
RETURN MAX(a.ID) AS numMax          -- returns the max value
RETURN MIN(a.ID) AS numMin          -- returns the min value
RETURN SUM(a.ID) AS numSum          -- returns the sum
```  

### List comprehension  
```OpenCypher
RETURN [e IN RELATIONSHIPS(p) | e.TARGET] AS result
```  
Constructs a new list from the given path function in JSON format, returning a list of edges and
the given expression that uses the given iterator variable.  
```OpenCypher
RETURN { from: e.SOURCE, to: e.TARGET } AS result
```  
String representation of the result in JSON format.  
"
73;268;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Multisets;"
### Constructors  
```graphscript
MULTISET<VERTEX> m1(:g);
```  
Constructs an empty vertex multiset.  
```graphscript
MULTISET<VERTEX> m2 = { :v1, :v2 };
```  
Constructs vertex multiset with vertices `:v1` and `:v2`.  
```graphscript
MULTISET<INTEGER> m3;            -- empty multiset
MULTISET<INTEGER> m4(:seq_int);  -- creates a multiset from the given sequence
```  
Constructs a collection of scalars.  
```graphscript
MULTISET<MULTISET<BIGINT>> m5 = {{2L, 2L}, {1L, 3L}, {3L, 1L}};
```  
Constructs a nested multiset of scalars.  

### Operations  
```graphscript
DISTINCT(:m1)
:m1 INTERSECT [ALL] :m2
:m1 UNION [ALL] :m2
:m1 EXCEPT [ALL] :m2
```  
Removing `ALL` is equivalent to a subsequent `DISTINCT`.  
```graphscript
BIGINT sz = COUNT(:m1);
```  
Calculates the size of the Multiset.  
```graphscript
BOOLEAN b1 = :m1 == :m2;
BOOLEAN b2 = :m1 != :m3;
```  
Compares two multisets for equality or inequality.  
"
74;265;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Existence Expression;"```graphscript
VERTEX_EXISTS(:g, 'keyVal')
EDGE_EXISTS(:g, 'label', 3)
```  
"
75;116;60;40;0;060-040-000-Table_Operations.md;Table Operations;Return Table Statement;"A GraphScript table function must return a table of the type defined in the return clause
of the function definition. The GraphScript return table statement has the following syntax:  
```bnf
<return_table_statement> ::= RETURN <projection_expr> ;
```  
The return table statement terminates the execution of the current function and
returns the specified table to the caller. Return table statements are supported
only in GraphScript table functions and not in procedures or anonymous blocks.  

### Example  
```sql
CREATE OR REPLACE FUNCTION myTableFunction (val INTEGER)
RETURNS TABLE(NAME NVARCHAR, ATTR INTEGER)
LANGUAGE GRAPH AS
BEGIN
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(VERTEX INTEGER ATTR = :val);
RETURN SELECT :v.""NAME"", :v.attr FOREACH v IN VERTICES(:g);
END;
```  
<!--! section id=""section_jbf_nqc_1hb"" -->"
76;31;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;Comments;"GraphScript supports both single-line and multiline comments.  
A single-line comment starts with ""--""; all characters that follow in the line are treated as a
comment.
A multiline comment is enclosed in ""/*"" and ""*/"".  

### Examples  
```graphscript
INTEGER v = 23; -- this is a single line comment  
```  
```graphscript
FOREACH e IN Edges(:g) {
/* this is a multi line comment
INTEGER i = :e.attr;
INTEGER v = 23;*/
}
```  
"
77;243;70;20;50;070-020-050-Basic_Building_Blocks.md;Basic Building Blocks;BNF Terminal Symbols;"```bnf
<backtick> ::= `
<dot> ::= .
<double_dot> ::= ..
<comma> ::= ,
<minus> ::= -
<l_paren> ::= (
<r_paren> ::= )
<l_curly> ::= {
<r_curly> ::= }
<l_square> ::= [
<r_square> ::= ]
<greater> ::= >
<equal> ::= =
<lower> ::= <
<lower_equal> ::= <=
<greater> ::= >
<greater_equal> ::= >=
<unequal> ::= <>
<asterisk> ::= *
<single_quote> ::= '
<double_quote> ::= ""
<backslash> ::= \
<zero> ::= 0
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<positive_digit> ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q |
r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J |
K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
<any_char> ::= any character !!
```"
78;128;60;50;20;060-050-020-Non-Numeric_Scalar_Types.md;Non-Numeric Scalar Types;Spatial object type;"The ST_GEOMETRY data type stores a spatial object. An ST_GEOMETRY variable is default-initialized
with value NULL. Support of ST_GEOMETRY in the Graphscript language is limited. Currently, it is
only possible to read ST_GEOMETRY values from vertex or edge attributes or local variables. The
values may be assigned to a local ST_GEOMETRY variable or to an output column using cell access or
projection statements. More information about the data type can be found in the
[SAP HANA Spatial documentation](loio7a1f0883787c101495ac9074d9bf3923).  
GraphScipt supports all methods of ST_GEOMETRY that are listed in the (SAP HANA Spatial documentation)
which do not return ST_GEOMETRY or VARBINARY. In contrast to the use in SQL, the spatial methods are
called as functions in GraphScript.  
### Examples  
```graphscript
ST_GEOMETRY my_geom = :inTab.val[1L]; -- inTab contains a geometry like this: LINESTRING(0 0, 0 1)
BOOLEAN isValid = ST_ISVALID(:my_geom);
INTEGER lengthInMeter = ST_LENGTH(:my_geom, 'meter');
BOOLEAN isWithin = ST_WITHINDISTANCE(:my_geom, :my_geom, 0.0);
```  
<!--! related-links -->"
79;194;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;ADD_HOURS;"Computes the specified TIMESTAMP value, plus or minus the specified hours. The value to be added or
subtracted needs to be an INTEGER.  
- ADD_HOURS(TIMESTAMP, INTEGER) => TIMESTAMP  
"
80;117;60;40;0;060-040-000-Table_Operations.md;Table Operations;Table Column Cast Expressions;"A table column can also be cast to a multiset, a sequence or a map of scalars, provided that their element primitive types match.  
```bnf
<multiset_init_expr> ::=  MULTISET '<' <primitive_type> '>' '(' <attr_access_expr> ')'  
<sequence_init_expr> ::=  SEQUENCE '<' <primitive_type> '>' '(' <attr_access_expr> ')'  
<sequence_init_expr> ::=  MAP '<' <primitive_type>, <primitive_type> '>' '(' <attr_access_expr>, <attr_access_expr> ')'
```  

### Examples  
```graphscript
SEQUENCE<INTEGER> si = SEQUENCE<INTEGER>(:i_tab.""ATTR"");
MULTISET<INTEGER> mi = MULTISET<INTEGER>(:i_tab.""ATTR"");
MAP<INTEGER, BIGINT> m = MAP<INTEGER, BIGINT>(:i_tab.""ATTR"", :b_tab.""BIGATTR"")  
-- using shorthand notation
SEQUENCE<INTEGER> si(:i_tab.""ATTR"");
MULTISET<INTEGER> mi(:i_tab.""ATTR"");
MAP<INTEGER, BIGINT> m(:i_tab.""ATTR"", :b_tab.""BIGATTR"")
```"
81;1;10;0;0;010-000-000-SAP_HANA_Graph_Reference.md;SAP HANA Cloud Graph Reference;;"This reference provides information about SAP HANA Graph.
It is organized as follows:  
- Introduction  
Introduction to SAP HANA Graph.  
- SAP HANA Graph Data Model  
Description of SAP HANA Graph data model using a simple example.  
- Graph Workspaces  
Description of SQL statements for creating and manipulating graph workspaces.  
- Graph Data Modification  
Description of SQL statements for modifying graph data.  
- GraphScript Language  
Description of the GraphScript stored procedure language.  
- openCypher Query Language  
Description of the openCypher query language interface in SAP HANA (Cypher is a registered
trademark of Neo4j, Inc.).  
- Additional Information  
A collection of additional information."
82;133;60;50;30;060-050-030-Typed_Literals.md;Typed Literals;Boolean Literals;"A Boolean literal can be either TRUE or FALSE.
Both literals are keywords in GraphScript and therefore are case-insensitive.  
"
83;142;60;50;40;060-050-040-Type_Casts.md;Type Casts;DATE;"Casts a NVARCHAR value to a DATE value.  
- DATE(DATE) => DATE
- DATE(NVARCHAR) => DATE  
It is also possible to provide a second argument having type DATE.  
- DATE(DATE,DATE) => Returns the first argument as long it is not NULL, else it returns the second
argument.
- DATE(NVARCHAR,DATE) => Type casts NVARCHAR to DATE. If it fails or is NULL, it returns the second argument.  
```graphscript
DATE var1 = DATE('1972-04-01');
DATE var2 = DATE('HANA', :var1); -- var2 is '1972-04-01'
```"
84;20;40;40;0;040-040-000-Graph_Metadata_Views.md;Graph Metadata Views;GRAPH_WORKSPACE_COLUMNS System View;"This system view provides information on the constituent entities and columns of graph workspaces.  
Besides the constituent key, source, and target columns, the view also shows the other vertex and
edge table columns that can be used within graph scripts or queries, but only if the referenced
vertex/edge table currently exists. The key, source, and target columns are always shown, even if
these tables currently do not exist, because this information is directly based on the workspace
definition.  

### Structure  
|Column name|Data type|Description|
|---|---|---|
|SCHEMA_NAME|NVARCHAR(256)|The workspace schema name.|
|WORKSPACE_NAME|NVARCHAR(256)|The workspace name.|
|ENTITY_TYPE|NVARCHAR(6)|The entity type (VERTEX or EDGE).|
|ENTITY_SCHEMA_NAME|NVARCHAR(256)|The entity object schema name.|
|ENTITY_TABLE_NAME|NVARCHAR(256)|The entity object table or view name.|
|ENTITY_COLUMN_NAME|NVARCHAR(256)|The entity object column name.|
|ENTITY_ROLE|NVARCHAR(6)|The role of column (KEY, SOURCE, or TARGET. NULL for vertex or edge properties).|
|ENTITY_ROLE_POSITION|INTEGER|The position of the column in a composite key, source, or target (otherwise NULL).|
|ENTITY_LABEL|NVARCHAR(5000)|The explicitly defined label of the vertex or edge table the column belongs to (otherwise NULL).|
|REFERENCED_SCHEMA_NAME|NVARCHAR(256)|For the edge source and target columns, the schema name of the referenced vertex table (NULL for all other columns).|
|REFERENCED_TABLE_NAME|NVARCHAR(256)|For the edge source and target columns, the table name of the referenced vertex table (NULL for all other columns).|"
85;236;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;RELATIONSHIPS;"The RELATIONSHIPS function takes a path variable and returns a collection of all edges in the path.  
```bnf
<relationships_function> ::= RELATIONSHIPS '(' <variable_name> ')'
```  
<!--! section id=""section_tvb_jlh_4bb"" -->"
86;151;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;BITAND;"- BITAND(INTEGER,INTEGER) => INTEGER
- BITAND(BIGINT,BIGINT) => BIGINT  
"
87;103;60;30;20;060-030-020-Sequence.md;SEQUENCE;Order Expressions;"An order expression sorts the elements of a sequence. For Vertices and Edges it is necessary to
specify the attributes determining the order. If multiple attributes are given, they are used
sequentially in case of equality in the preceding attribute. It is possible to specify the order
direction. The default direction is Ascending. NULL values are placed first in case of ascending
direction.
Currently, this is not supported for nested sequences.  
```
<order_expr> ::= <expr> ORDER BY <arguments>
| <expr> ORDER [ <direction> ]  
<arguments> ::= <l_paren> <argument_list> <r_paren>
| <argument>  
<argumentList> ::= <argument>
| <argument_list> <comma> <argument>  
<argument> ::= <identifier> [ <direction> ]  
<direction> ::= ASC
|   DESC
```  

### Examples  
```
SEQUENCE<INT> s26 = [2,3,1] ORDER ASC;
SEQUENCE<VERTEX> s27 = [VERTEX(:g,1), VERTEX(:g,2)] ORDER BY (""KEY"" ASC, ""Attr"" DESC);
```"
88;50;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;IN_DEGREE;"Returns the number of incoming edges of a vertex.  
- IN_DEGREE(VERTEX) => BIGINT  
"
89;85;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;K-shortest Paths;"```bnf
<ksp_function> ::= K_SHORTEST_PATHS '(' <parent_graph_variable>,
<source_vertex>, <target_vertex>, <num_paths> [ , <clos_expr> ] ')'  
<parent_graph_variable> ::= <variable_reference>
<start_vertex> ::= <expr>
<target_vertex> ::= <expr>
<num_paths> ::= <expr>
```  
Returns a sequence of [WEIGHTEDPATH](loio5fd3b8657aec4382b4642780c80940d0) instances containing the num_paths (fourth parameter) shortest
paths within the given parent graph from a start vertex (second parameter) to a target vertex (third
parameter). By default, the weight metric of the K_SHORTEST_PATHS built-in function is the hop
distance, but itâ€™s also possible to supply a custom weight function (optional fourth parameter).
See [Shortest Path](loio3b0a971b129c446c9e40a797bdb29c2b/section_shortest_path) for details on the weight function.
The function creates paths that might contain cycles. The paths in the sequence are ordered by
increasing length.  
Please note that K_SHORTEST_PATHS doesnâ€™t support the weight and hop distance parameters inside the
weight function. Furthermore, the END TRAVERSE statement is not supported.  

### Examples  
The following example demonstrates the usage of the K_SHORTEST_PATHS function.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX v_source(:g, 'FRA');
VERTEX v_target(:g, 'JFK');
SEQUENCE<WEIGHTEDPATH<BIGINT>> paths = K_SHORTEST_PATHS(
:g, :v_source, :v_target, 3);  
FOREACH p IN :paths {
-- process the path
BIGINT l = LENGTH(:p);
BIGINT w = WEIGHT(:p);
FOREACH v in VERTICES(:p) {
-- ....
}
}
```  
The following example demonstrates the use of a custom weight function of various types.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(EDGE INTEGER price = 1);
VERTEX v_source(:g, 'FRA');
VERTEX v_target(:g, 'JFK');
SEQUENCE<WEIGHTEDPATH<INTEGER>> cheapest_paths = K_SHORTEST_PATHS(
:g, :v_source, :v_target, 3,  (EDGE e) => INTEGER{ RETURN :e.price; });
SEQUENCE<WEIGHTEDPATH<BIGINT>> least_stopovers = K_SHORTEST_PATHS(
:g, :v_source, :v_target, 3,  (EDGE e) => BIGINT{ RETURN 1L; });
SEQUENCE<WEIGHTEDPATH<DOUBLE>> shortest_paths = K_SHORTEST_PATHS(
:g, :v_source, :v_target, 3,  (EDGE e) => DOUBLE{ RETURN :e.""DIST_KM""; });
```  
"
90;209;60;60;0;060-060-000-Restrictions.md;Restrictions for GraphScript Procedures;General Graph Workspace Limitations;"- Caching isn't supported for graph workspaces that refer to virtual tables.
- The usage of cross-database access in a scenario with more than one tenant database in combination
with SAP HANA Graph isn't supported."
91;245;90;20;0;090-020-000-Appendix_A_-_Open_Flights_Graph_Example.md;Appendix A - Open Flights and Company Graph Examples;;"Use the following SQL statements to create the Open Flights and Company graph examples.  
<!--! section id=""section_open_flights_example"" -->"
92;26;60;5;0;060-005-000-Integration_into_Stored_Procs.md;Integration into the SAP HANA Environment;GraphScript Procedures;"GraphScript procedures do not make any modifications to the database data or its structure
and are therefore marked as read-only. Similar to SQLScript procedures,
GraphScript procedures support debugging from the SAP HANA Database Explorer.  
<!--! subsection id=""GraphScript_Procedure_Syntax""-->
### Syntax  
Creates a GraphScript procedure.  
```bnf
CREATE [OR REPLACE] PROCEDURE <procedure_name> (<procedure_parameters>)
LANGUAGE GRAPH [<sql_security_mode>] [<default_schema_specification>]
READS SQL DATA AS
BEGIN
<GraphScript_procedure_body>
END
```
<!--! subsection id=""GraphScript_Procedure_Syntax_Elements""-->
### Syntax Elements  
#### <procedure_name>  
Specifies the name of the procedure with an optional schema name.  
```bnf
<procedure_name> ::= [<schema_name>.]<identifier>
```  
#### <procedure_parameters>  
Specifies the parameters of the procedure.  
```bnf
<procedure_parameters> ::= <in_out_inout_parameter> [ { , <in_out_inout_parameter> } [...] ]  
<in_out_inout_parameter> ::= <in_out_inout_specifier> <parameter_name> <data_or_table_type>  
<in_out_inout_specifier> ::= IN | OUT | INOUT  
<parameter_name> ::= <identifier>  
<data_or_table_type> ::= <scalar_data_type> | <table_type> | <table_type_definition>  
<scalar_data_type> ::=
INTEGER
| BIGINT
| DOUBLE
| BOOLEAN
| NVARCHAR [ (<unsigned_integer>) ]
| TIMESTAMP
```  
The input and output parameters of a procedure can have any of the
[primitive SQL types supported by GraphScript](loio35d820db40f5444d89a11e2c92a2ad7d)) or a table type.
INOUT parameters must be of a supported scalar type - table type parameters are either IN or OUT parameters.
The default value of scalar output parameter variables is NULL.  
#### <table_type>  
Specifies a table type that was previously defined with the CREATE TYPE statement.  
```bnf
<table_type> ::= [<schema_name>.]<identifier>
```  
#### <table_type_definition>  
Specifies a table type that is defined within the signature of the procedure.  
```bnf
<table_type_definition> ::= TABLE (<column_list_definition>)  
<column_list_definition> ::= <column_definition> [ { , <column_definition> } [...] ]  
<column_definition> ::= <column_name> <scalar_data_type>  
<column_name> ::= <identifier>
```  
Table parameters with primary key or unique constraints are not supported.
Additionally, the columns of output tables must be NULL-able.
Therefore, NOT NULL constraints are not supported for output tables.  
#### <sql_security_mode>  
Specifies the security mode of the procedure. The default is DEFINER.  
```bnf
<sql_security_mode> ::= SQL SECURITY <mode>
<mode> ::= DEFINER | INVOKER
```  
In the DEFINER security mode, the execution of the procedure is performed with the privileges of the definer of the procedure.
In the INVOKER security mode, the execution of the procedure is performed with the privileges of the invoker of the procedure.  
#### <default_schema_specification>  
Specifies the schema for unqualified objects in the procedure.
If the optional default schema specification is missing,
then the current schema of the session at the time of the procedure definition is used.  
```bnf
<default_schema_specification> ::= DEFAULT SCHEMA <schema_name>
```  
<!--! subsection id=""GraphScript_Procedure_Description""-->
### Description  
Once a procedure has been created, the CALL procedure statement can be used to executed the procedure.
Procedures can be dropped using the DROP PROCEDURE statement.  
The [example](loio95320185c30b4565853f22062a42c219/section_procedure_example)
illustrates the creation and usage of a GraphScript procedure.  
<!--! section id=""GraphScript_Anonymous_Block"" -->"
93;266;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Filter Expression;"```graphscript
v IN VERTICES(:g) WHERE :v.attr > 23
```  
"
94;118;60;50;0;060-050-000-Scalar_Data_Types_and_Operations.md;Scalar Data Types and Operations;;"GraphScript supports scalar data types and operations.  
The following table summarizes the supported scalar data types in GraphScript and classifies them by
their characteristics:  
|Classification|Data Type|
|---|---|
|Numeric types|INTEGER, BIGINT, DOUBLE|
|Boolean type|BOOLEAN|
|Character string type|NVARCHAR|
|Datetime type|TIMESTAMP|
|Binary character string type|VARBINARY|
|Spatial data object|ST_GEOMETRY|  
All scalar variables support the special value NULL."
95;136;60;50;40;060-050-040-Type_Casts.md;Type Casts;BOOLEAN;"Casts a BOOLEAN value to a BOOLEAN value.  
- BOOLEAN(BOOLEAN) => BOOLEAN  
It is also possible to provide a second argument having type BOOLEAN. If the type casting fails or
the first argument is NULL, then the second argument is returned. Similar applies to other type
casts with second argument.  
- BOOLEAN(BOOLEAN,BOOLEAN) => Returns the first argument as long it is not NULL, else it returns the second.
argument  
```graphscript
BOOLEAN var1 = BOOLEAN(true); -- var1 is true
BOOLEAN nullVal;
BOOLEAN var2 = INTEGER(:nullVal, false); -- var2 is false as the first value is null
```  
"
96;3;30;0;0;030-000-000-SAP_HANA_Graph_Data_Model.md;SAP HANA Graph Data Model;;"Graphs are a powerful abstraction that can model different kinds of networks and linked
data coming from many industries, such as logistics and transportation, utility networks, knowledge
representation, and text processing.  
In SAP HANA, a graph is made up by a set of vertices and a set of edges.
Vertices are the entities in the graph while the edges describe the relationships between vertices.
Each edge connects two vertices - one vertex is denoted as the source and the other as the target.
Edges are always directed, yet they can be navigated in either direction.
Any number of edges may connect the same two vertices.
Vertices and edges can have an arbitrary number of attributes.
An attribute consists of a name that is associated with a data type and a value.
Additionally, each vertex may have an associated label, which represents the role of the vertex in the modeled domain.
Edges also may have an associated label which represents the role of the edge in the modeled domain.  
Vertices are stored in vertex tables, while edges are stored in edge tables.
Vertex and edge tables are collectively denoted as graph tables.
A graph table can be any relational object of type table, view or synonym.
Vertex attributes correspond to the columns of the vertex tables,
and edge attributes correspond to the columns of the edge tables.
The maximum number of attributes is bound by the maximum number of
columns for the underlying tables.  
Relational storage allows the whole feature set of SAP HANA to be applied to the graph data:
access control, backup and recovery, and so on.
It also allows all SAP HANA Graph functions to be applied to the graph data stored in relational
format coming from business applications.  
SAP HANA Graph provides graph workspaces as dedicated catalog objects for defining graphs.  
<!--! related-links -->"
97;144;60;50;50;060-050-050-Arithmetic_Expressions.md;Arithmetic Expressions;Examples;"```
INTEGER suma = 2 + 3;
BIGINT prod = 2L * 3L;
DOUBLE quot = 2.0 / 3.0;
INTEGER modulo = 10 % 3;
```"
98;97;60;30;10;060-030-010-Multiset.md;MULTISET;Filter Expressions;"A filter expression evaluates a predicate for each element of an input container. The matching
elements are returned as a multiset. Within the WHERE clause of the filter expression, it is
possible to access temporary variables, and temporary and non-temporary attributes of vertices and
edges, to use built-in functions, and to call functions. For filter expressions on sequence
containers, an optional ordinal variable can be used to access the ordinal position of the element
currently being processed.  
```
<filter_expr> ::= <variable> IN <expr> [ WITH ORDINALITY AS <variable> ]
WHERE <expr>
```  

### Examples  
```
INT tmp = 2;
v IN Vertices(:g) WHERE :v.color == 'green' AND :v.numEyes != 2;
v IN Vertices(:g) WHERE :v.id <= COUNT(Vertices(:g)) AND :v.numEyes == :tmp;
```"
99;181;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;DATE;"Creates a DATE value from the given character string.
Throws a conversion error if the character string isn't a valid DATE value.  
- DATE(NVARCHAR) => DATE  
"
100;131;60;50;30;060-050-030-Typed_Literals.md;Typed Literals;Numeric Literals;"A numeric literal is represented by a sequence of digits that aren't enclosed in quotation
marks. If a numeric literal contains a decimal point, then it's treated as a DOUBLE precision
floating point value. BIGINT literals need to be suffixed with an L.  
```bnf
<int_literal> ::= 0 | <pos_digit> {<digit>}
<bigint_literal>      ::= <int_literal> L
<double_literal>      ::= ( 0 | <pos_digit> {<digit>}) <dot> <digit> {<digit>}
<numeric_literal>     ::= <int_literal> | <bigint_literal> | <double_literal>
```  

### Examples  
```graphscript
123 -- INTEGER
123L -- BIGINT
123.4 -- DOUBLE
```  
"
101;186;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;HOUR;"Extracts the hour component from a TIMESTAMP value.  
- HOUR(TIMESTAMP) => INTEGER  
"
102;235;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;DATE;"The DATE() function takes a string value in YYYY-MM-DD format and converts it to date value with
year, month and day component values.  
```bnf
<datetime_function> ::= DATETIME '(' <variable_name> '.' <attribute_name> ')'
```  
DATE(NULL) returns NULL. An error is thrown if the parsing fails.  
<!--! section id=""section_vwy_3lh_4bb"" -->"
103;191;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;ADD_NANO100;"Computes the specified TIMESTAMP value, plus or minus the specified number of 0.1 microsecond units.
The value to be added or subtracted needs to be a BIGINT.  
- ADD_NANO100(TIMESTAMP, BIGINT) => TIMESTAMP  
"
104;150;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;ATAN2;"- ATAN2(DOUBLE,DOUBLE) => DOUBLE  
"
105;276;90;50;0;090-050-000-Appendix_D_-_OpenCypher_Cheat_Sheet.md;Appendix C - openCypher Cheat Sheet;;"openCypher is a declarative graph query language for graph pattern matching. An openCypher query
searches for subgraphs that match the pattern given in MATCH clauses and returns a result
table as specified in the RETURN clause.  
"
106;107;60;30;30;060-030-030-Map.md;MAP;Operations;"
### Access  
Operator [] can be used to read and write to a map via a given key.  
```graphscript
MAP<INTEGER, INTEGER> mapInt(10L, 42);
INTEGER defaultVal = :mapInt[4]; -- default is 42
mapInt[10] = 5; -- store value 10 at key 5
INTEGER val = :mapInt[10]; -- val is 5
```"
107;127;60;50;20;060-050-020-Non-Numeric_Scalar_Types.md;Non-Numeric Scalar Types;Varbinary Type;"The VARBINARY data type stores binary character data of variable length. A varbinary variable is
default-initialized with value NULL.  
"
108;77;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Is Reachable;"Tests for the existence of at least one path from vertex v1 to vertex v2.  
- IS_REACHABLE(GRAPH, VERTEX, VERTEX) => BOOL  
"
109;36;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;Conditional Statements;"A conditional statement consists of an IF body and an optional ELSE body.
Each body contains an arbitrary number of statements enclosed in curly braces.
If the expression <expr> in the IF branch evaluates to TRUE, the corresponding statements in the IF
body are executed, otherwise the statements in the ELSE branch are executed.  
```bnf
<conditional> ::= IF '(' <expr> ')'
'{' <statements> '}'
[ ELSE '{' <statements> '}' ]
```  

### Examples  
```graphscript
INTEGER i;
IF (2 < 3) {
IF (TRUE) {
i = 5;
} ELSE {
i = 17;
}
}
```  
"
110;137;60;50;40;060-050-040-Type_Casts.md;Type Casts;INTEGER;"Casts a DOUBLE or BIGINT value to an INTEGER value.
Throws a conversion error in the event of value overflows or underflows.  
- INTEGER(INTEGER) => INTEGER
- INTEGER(DOUBLE) => INTEGER
- INTEGER(BIGINT) => INTEGER  
It is also possible to provide a second argument having type INTEGER. If the type casting fails or
the first argument is NULL, then the second argument is returned. Similar applies to other type
casts with second argument.  
- INTEGER(INTEGER,INTEGER) => Returns first argument as long it is not NULL, else returns second
argument
- INTEGER(DOUBLE,INTEGER) => Type casts DOUBLE to INTEGER. If it fails or is NULL, it returns the second argument.
- INTEGER(BIGINT,INTEGER) => Type casts BIGINT to INTEGER. If it fails or is NULL, it returns the second argument.  
```graphscript
INTEGER var1 = INTEGER(5.1, 2); -- var1 is 5
INTEGER var2 = INTEGER(4000000000L, 2); -- var2 is 2 as value overflows during casting
```  
"
111;79;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Inverse Graph;"Constructs the inverse graph of a given graph.  
```bnf
<inversegraph_function> ::= INVERSEGRAPH '(' <parent_graph_variable> ')'
<parent_graph_variable> ::= <variable_reference>
```  
Returns the inverse graph of the given parent graph. All vertices of the parent graph are copied
into the resulting inverse graph without any modification. All edges of the parent graph are copied
into the resulting inverse graph with swapped edge direction. The values for all vertices as well as
edge attributes are copied from the parent graph. Attribute handling is identical to subgraphs.  
On inverse graphs, the `SOURCE(:e)` and `TARGET(:e)` functions return the inverse result, whereas
accessing the edge's source and target key attributes returns the original values.  

### Examples  
In the following example, we manually construct a multiset `neighborsFRA` of all direct neighbors of
`FRA` independently of the edge direction using INVERSEGRAPH. Note that we use a FOREACH loop to get
the corresponding vertices in Graph G by key, as using the UNION operation for multisets from
different graphs isnâ€™t permitted.  
This example is an artificial one for the sake of demonstrating the INVERSEGRAPH
function. The same result could be achieved much more efficiently by calling the NEIGHBORS function
with a distance window from -1 to 1.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
MULTISET<VERTEX> neighborsFRA = NEIGHBORS(:g, VERTEX(:g, 'FRA'), 1, 1);
GRAPH gi = INVERSEGRAPH(:g);
FOREACH v IN NEIGHBORS(:gi, { VERTEX(:gi, 'FRA') }, 1, 1) {
neighborsFRA = :neighborsFRA UNION { VERTEX(:g, :v.""NODE_KEY"") };
}
```  
"
112;15;40;20;0;040-020-000-Drop_Graph_Workspace.md;DROP GRAPH WORKSPACE Statement (Data Definition);Description;"In order to drop a graph workspace, the user must be either the creator of
the graph workspace or have the `DROP` privilege for the given graph workspace.  
Dropping a graph workspace does not affect the underlying vertex and edge tables.  
<!--! section id=""section_cgw_examples"" -->"
113;96;60;30;10;060-030-010-Multiset.md;MULTISET;Operations;"Set operations take two multisets and produce a new multiset. The types of both arguments and the
result have to match. If there are multisets of vertices or edges, the vertices or edges must come
from the same graph.  
In case of UNION ALL, the second argument can be a single element.  
```bnf
<set_op_expr> ::= <expr> <set_op> <expr>
<set_op> ::= <union> | <union_all> | <intersect> | <intersect_all> | <except> | <except_all>
```  
```graphscript
MULTISET<BIGINT> m17 = {1L, 2L} UNION {2L, 3L}; -- m17 is {1L, 2L, 3L}
MULTISET<MULTISET<BIGINT>> m18 = {{1L}, {3L, 2L}} UNION {{2L, 3L}}; -- m18 is {{1L}, {3L, 2L}}
```  

### UNION ALL  
Returns a multiset containing all elements from both arguments.
Duplicates aren't removed.  
```graphscript
MULTISET<BIGINT> m19 = {1L, 2L} UNION ALL {2L, 3L}; -- m19 is {1L, 2L, 2L, 3L}
m19 = :m19 UNION ALL 1L; -- m19 is {1L, 2L, 2L, 3L, 1L}  
MULTISET<MULTISET<BIGINT>> m20 = {{1L}, {3L, 2L}} UNION ALL {{1L}}; -- m20 is {{1L}, {3L, 2L}, {1L}}
m20 = :m20 UNION ALL {2L, 3L}; -- m20 is {{1L}, {3L, 2L}, {1L}, {2L ,3L}}
```  

### UNION  
Returns all unique elements from both arguments by removing the duplicates found.
UNION has the same result as UNION ALL with a subsequent DISTINCT.  

### INTERSECT ALL  
Returns all elements that are present in both arguments.
Duplicates aren't removed.  

### INTERSECT  
Returns all unique elements that are present in both arguments.
Duplicates are removed.
INTERSECT has the same result as INTERSECT ALL with a subsequent DISTINCT.  

### EXCEPT ALL  
Returns all elements that are present in the left-hand argument but not in the right-hand
argument. Duplicates aren't removed.  
```graphscript
MULTISET<NVARCHAR> m21 = {'a', 'a', 'b', 'b'};
MULTISET<NVARCHAR> m22 = {'a'};
MULTISET<NVARCHAR> m23 = :m21 EXCEPT ALL :m22; -- m23 is {'b', 'b'}  
VERTEX v1(:g, 1);
VERTEX v2(:g, 2);
MULTISET<MULTISET<VERTEX>> m24 = {{:v1}, {:v1,:v2}, {:v1,:v2,:v1}, {:v2,:v1}, {:v2}};
MULTISET<MULTISET<VERTEX>> m25 = {{:v1}, {:v2, :v1}, {:v1,:v1,:v2}};
MULTISET<MULTISET<VERTEX>> m26 = :m24 EXCEPT ALL :m25; -- m26 is {{:v2}, {:v1, :v2}}
```  

### EXCEPT  
Returns all unique elements that are present in the left-hand argument but not in the right-hand
argument. Duplicates are removed. EXCEPT has the same result as EXCEPT ALL with a subsequent
DISTINCT.  
```graphscript
MULTISET<NVARCHAR> m27 = {'a', 'a', 'b', 'b'};
MULTISET<NVARCHAR> m28 = {'a'};
MULTISET<NVARCHAR> m29 = :m27 EXCEPT :m28; -- m29 is {'b'}  
MULTISET<MULTISET<NVARCHAR>> m30 = {{'a', 'b'}, {'a', 'c'}, {'c', 'a'}, {'a', 'd', 'b'}};
MULTISET<MULTISET<NVARCHAR>> m31 = {{'a'}, {'a', 'd', 'b'}};
MULTISET<MULTISET<NVARCHAR>> m32 = :m30 EXCEPT :m31; -- m32 is {{'a', 'b'}, {'a', 'c'}}
```  

### Comparison  
Compares two multisets for equality using '==' or inequality using '!=' operator.  
```graphscript
MULTISET<INTEGER> m33 = {1, 2, 2, 3};
BOOL b1 = :m33 == {2, 1, 3, 2}; -- b1 is true
BOOL b2 = :m33 != {2, 3, 1}; -- b2 is true  
MULTISET<MULTISET<INTEGER>> m34 = {{1, 2}, {2, 3}};
BOOL b3 = :m34 == {{2, 1}, {3, 2}}; -- b3 is true
BOOL b4 = :m34 != {{2, 3}, {1}}; -- b4 is true
```  
"
114;27;60;5;0;060-005-000-Integration_into_Stored_Procs.md;Integration into the SAP HANA Environment;GraphScript Anonymous Blocks;"A GraphScript anonymous block is an executable DML statement which may contain an
arbitrary GraphScript program. For anonymous blocks, no corresponding object is
created in the catalog.  
<!--! subsection id=""GraphScript_Anonymous_Block_Syntax""-->
### Syntax  
A GraphScript anonymous block is defined and executed in a single step by using
the following syntax:  
```bnf
DO [(<anonymous_block_parameters>)] LANGUAGE GRAPH
BEGIN
<body>
END  
<body> ::= !! supports the same feature set as GraphScript procedures
```  
The mandatory language identifier for GraphScript anonymous blocks is GRAPH.
Anonymous blocks are always read only. Therefore, the READS SQL DATA specification is not needed.  
<!--! subsection id=""GraphScript_Anonymous_Block_Syntax_Elements""-->
### Syntax Elements  
#### <anonymous_block_parameters>  
Describes the parameters of the anonymous block.  
```bnf
<anonymous_block_parameters> ::= <named_parameter> [ { , <named_parameter>} [...] ]  
<named_parameter> ::= {IN | OUT} <parameter_name> <parameter_type> => <parameter_value>  
<parameter_name> ::= <identifier>  
<parameter_type> ::= <scalar_data_type> | <table_type> | <table_type_definition>  
<parameter_value> ::= ? | <identifier> | <string_literal> | <unsigned_integer> |
<signed_integer> | <signed_numeric_literal> | <unsigned_numeric_literal> | <expression>
```  
<!--! subsection id=""GraphScript_Anonymous_Block_Description""-->
### Description  
Anonymous blocks only support IN and OUT parameters - unlike procedures they do not support INOUT parameters.
GraphScript anonymous blocks support the same data types as GraphScript procedures.
Analogous to procedures, the default value of scalar output parameter variables is NULL.  
Unlike the parameter definition in the CREATE PROCEDURE statement,
anonymous block parameters require in-place initialization using the '=>' syntax.
Input parameters can be initialized either with scalar expressions or like prepared parameters with '?'.
The values of the prepared parameters must be provided when the block is executed.
The anonymous block is compiled only once and it can be executed multiple times
with different prepared parameter values. Output parameters must be initialized with '?'.  
```sql
DO (IN in_val BigInt => ?, OUT out_val BigInt => ?) LANGUAGE GRAPH
BEGIN
out_val = :in_val;
END
```  
Anonymous blocks cannot be used within procedures or functions.  
Currently, GraphScript anonymous blocks do not provide support for debugging.  
The [example](loio95320185c30b4565853f22062a42c219/section_anonymous_block_example)
illustrates the usage of a GraphScript anonymous block with an output table parameter
for which the type is defined inline in the parameter list.  
<!--! section id=""GraphScript_Table_User_Defined_Function"" -->"
115;198;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;NANO100_BETWEEN;"Computes the time difference between two specified TIMESTAMP values to the precision of
0.1 microseconds.  
- NANO100_BETWEEN(TIMESTAMP, TIMESTAMP) => BIGINT  
"
116;38;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;WHILE Loops;"A WHILE loop repeats the statements specified in the loop body as long as the condition in the loop
head evaluates to true. Within a WHILE loop, the keywords BREAK and CONTINUE can be used.
BREAK stops the execution of the loop and CONTINUE skips to the next loop iteration.  
```bnf
<while_loop> ::= WHILE '(' <expr> ')' '{' <statements> '}'
```  

### Examples  
```graphscript
INTEGER a = 10;
WHILE (:a > 0) {
a = :a - 1;
}  
a = 10;
INTEGER b = 3;
WHILE (:a > 0) {
a = :a - 1;
IF( :a % 2 == 0 ) {
CONTINUE;
}
b = :b - 1;
IF(:b == 0) {
BREAK;
}
}
```"
117;174;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;UMINUS;"- UMINUS(INTEGER) => INTEGER
- UMINUS(BIGINT) => BIGINT
- UMINUS(DOUBLE) => DOUBLE"
118;74;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Community detection;"```bnf
<community_function> ::= COMMUNITIES_LOUVAIN'('<graph>[,<runs>[,<weight>[,<metric>[,<epsilon>]]]]')'
```  
Returns a SEQUENCE of MULTISET of VERTEX, representing partitioning of the vertices of a graph in communities.
Each multiset holds the vertices that belong to the same community.
A community is a group of vertices which are better connected to each other as compared to the vertices outside the community.
In other words, vertices are densely connected within a community and sparsely connected with the vertices of other communities.
The Louvain method [1] finds communities by optimizing the modularity metric (modularity is the only supported metric currently) locally for every vertex's neighbourhood iteratively.
It ends when the metric does not improve further.  
As the order in which the vertices are processed is random, the result is not deterministic and can change between each function call.
To get better results and to avoid local minima, this function allows to specify a number of runs, where a run is a complete execution of the Louvain method until a result has been found that can not be further optimized.
After all the runs have been completed, the function picks the best result and returns it.
Metric specific limitations like the resolution limit [2] for modularity can not be overcome this way.  
### Parameter
graph: Graph to apply the community detection on  
runs: Number of Louvain runs from which the best result is picked later on (Default: 1)  
weight: Function that provides an edge weight for each edge in the graph (Default: (Edge e) => DOUBLE{ return 1.0; })  
metric: Community metric that the Louvain algorithm uses to optimize communities (Default: 'MODULARITY')  
epsilon: Minimum change in the metric value between iterations.  
### Examples  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
SEQUENCE<MULTISET<VERTEX>> communities = COMMUNITIES_LOUVAIN(:g, 10, (Edge e) => DOUBLE{ return 1.0; });
```
Besides finding pure communities, it is desirable to work with the newly found communities. Such a workflow could be structured:
1.	Find communities
2.	Iterate over the communities
â€¢	Create a subgraph of the current community
â€¢	Apply graph algorithm to the subgraph
3.	Transform the communities to maps
4.	Project the result into a map
The related GraphScript code could look like the following:
```graphscript
GRAPH g = â€¦
SEQUENCE<MULTISET<VERTEX>> communities = COMMUNITIES_LOUVAIN(:g, 5);  
-- Community based calculations
FOREACH community in : communities
{
Graph communityGraph = SUBGRAPH(:g, :community);
â€¦
}  
-- Result projection
MAP<VERTEX, BIGINT> communityMap = TO_ORDINALITY_MAP(:communities);
myTable = SELECT :v.â€KEYâ€,  : communityMap [:v] FOREACH v in VERTICES(:g);
```  
### References
[1] Blondel, Vincent D., et al. ""Fast unfolding of communities in large networks."" Journal of statistical mechanics: theory and experiment 2008.10 (2008): P10008.
[2] Fortunato, Santo, and Marc Barthelemy. ""Resolution limit in community detection."" Proceedings of the national academy of sciences 104.1 (2007): 36-41.  
"
119;231;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;TOFLOAT;"The TOFLOAT() function takes an integer, floating point or a string value and converts it to a
floating point number.  
```bnf
<tofloat_function> ::= TOFLOAT '(' <variable_name> '.' <attribute_name> ')'
```  
TOFLOAT(NULL) returns NULL. An error is thrown if the parsing fails.  
<!--! section id=""_"" -->"
120;168;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;SIGN;"- SIGN(INTEGER) => INTEGER
- SIGN(BIGINT) => INTEGER
- SIGN(DOUBLE) => INTEGER  
"
121;158;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;COSH;"- COSH(DOUBLE) => DOUBLE  
"
122;200;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;DAYS_BETWEEN;"Computes the number of days between two specified DATE or TIMESTAMP values.  
- DAYS_BETWEEN(DATE, DATE) => INTEGER
- DAYS_BETWEEN(TIMESTAMP, TIMESTAMP) => INTEGER  
"
123;267;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Projection Expression;"```graphscript
tab = SELECT :v.id FOREACH v IN VERTICES(:g);
RETURN SELECT :v.id FOREACH v IN VERTICES(:g);
```  
"
124;98;60;30;20;060-030-020-Sequence.md;SEQUENCE;;"A sequence is an ordered collection. It is possible to access and modify any element through its
position, which is between 1L and the size of the sequence. Furthermore, it is also possible to
declare a nested sequence i.e. a container with an ordered collection of sequences.  
The elements of a sequence can be of type WEIGHTEDPATH; however, this is limited to the
result of K_SHORTEST_PATHS algorithm. Currently, a sequence of
WEIGHTEDPATH can only be read but not modified.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX v1(:g, 'FRA');
VERTEX v2(:g, 'JFK');
SEQUENCE<WEIGHTEDPATH<BIGINT>> swp = K_SHORTEST_PATHS(:g, :v1, :v2, 3);
```  
"
125;259;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Comments;"```graphscript
-- This is a one-line comment
/* This is
a multi-line comment */
```  
"
126;157;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;COS;"- COS(DOUBLE) => DOUBLE  
"
127;269;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Sequences;"
### Constructors  
```graphscript
SEQUENCE<VERTEX> s1(:g);
```  
Constructs an empty vertex sequence.  
```graphscript
SEQUENCE<VERTEX> s2 = [:v1, :v2];
```  
Constructs vertex sequence with vertices `:v1` and `:v2`.  
```graphscript
SEQUENCE<INTEGER> si(:tab.""colInt"");
```  
Constructs scalar sequence from table column.  
```graphscript
SEQUENCE<SEQUENCE<EDGE>> s3 = [[:e1], [:e2, :e3]];
```  
Constructs a nested sequence of edges.  

### Operations  
```graphscript
VERTEX v1   = :s1[1L];    -- read
s3[2L, 1L]  = :e1;        -- write
BIGINT sz   = COUNT(:s1); -- size
BOOLEAN b1  = :s1 == :s2; -- comparison
```  
Index starts at `1`.  
```graphscript
SEQUENCE<VERTEX> s4 = :s1 || :s2;
SEQUENCE<SEQUENCE<EDGE>> s5 = :s3 || [:e2, :e1];
```  
Concatenates two sequences or a sequence with an element.  
```graphscript
SEQUENCE<INT> s26 = [2,3,1] ORDER ASC;
```  
Sorts the elements of a sequence.  
"
128;68;60;20;50;060-020-050-Basic_Weighted_Path_Operations.md;Basic Weighted Path Operations;VERTICES;"Returns all vertices in a path.  
- VERTICES(WEIGHTEDPATH) => SEQUENCE  
"
129;228;70;20;30;070-020-030-Keywords.md;Keywords;Attribute Names, Variable Names, and Aliases;"Attribute names, variable names, and aliases are case-sensitive.  
The following query illustrates the case sensitivity of variable names (`a` and `A` aren't the
same).  
```OpenCypher
MATCH (a), (A)
RETURN a.NAME AS name
```  
This query also illustrates a disconnected graph pattern, since vertices `a` and `A` aren't
connected by any edge.
In other words, there are two connected components, each of them containing one vertex.
From a performance perspective, we recommend that you avoid matching disconnected subgraphs wherever
possible, because the result is the Cartesian product of matches of all connected components (225
rows), which can easily get large and use up system resources.  
The following query illustrates the case sensitivity of aliases and returns the values of the ""NAME""
attribute of all pairs of vertices in the given graph connected by an edge.  
```OpenCypher
MATCH (A)-[e]->(a)
RETURN a.NAME AS name, A.NAME as NAME
ORDER BY a.NAME ASC, A.NAME DESC
```"
130;106;60;30;30;060-030-030-Map.md;MAP;Functions;"
### COUNT  
Returns the number of entries stored in the map. The result type is BIGINT.  
```graphscript
MAP<INTEGER, INTEGER> mapInt(10L);
mapInt[1] = 2;
mapInt[2] = 4;
BIGINT mapCount = COUNT(:mapInt); -- mapCount is 2L
```  

### IS_EMPTY  
Returns true if the map has no elements.  
```graphscript
MAP<INTEGER, INTEGER> emptyMap(10L);
BOOL b1 = IS_EMPTY(:emptyMap); -- b1 is TRUE
emptyMap[26] = 5;
BOOL b2 = IS_EMPTY(:emptyMap); -- b2 is FALSE
```  

### TO_GROUP_SEQUENCE  
This function converts a MAP with VERTEX or EDGE as the key and a BIGINT
as the value to a SEQUENCE of MULTISET of the key. It groups
the keys with the same value in a MULTISET. Vertices or edges with no
or a default value will be ignored. These groupings are placed in
the SEQUENCE with the ordinality of the value. For example, a vertex
with value 3 would be put in the MULTISET that is located in the outer SEQUENCE
at position 4 (positions starts with 1, so a 1 is added to the value). A negative
value will result in an exception.
For a reverse operation that creates a MAP from a SEQUENCE of MULTISET, or a MAP
from a SEQUENCE of SEQUENCE, see
[TO_ORDINALITY_MAP](loio9401973fdc25430186a2a7978ea31e57) (MULTISET) or
[TO_ORDINALITY_MAP](loio58a3522a55ab44dcba2ce1d89974d38c) (SEQUENCE).  
```graphscript
MAP<VERTEX, BIGINT> ordMap (:g, 3L);
ordMap[:v1] = 0L;
ordMap[:v2] = 1L;
ordMap[:v3] = 0L;
SEQUENCE<MULTISET<VERTEX>> groupSeq= TO_GROUP_SEQUENCE(:ordMap);
: groupSeq == [{:v1,:v3}, {:v2}]; -- true
```  
"
131;101;60;30;20;060-030-020-Sequence.md;SEQUENCE;Operations;"
### Concatenation  
Returns a sequence by concatenating two sequences or concatenating a sequence with a single element.  
```graphscript
SEQUENCE<DOUBLE> s11 = [0.1, 0.2];
SEQUENCE<DOUBLE> s12 = :s11 || 0.3; -- s12 is [0.1, 0.2, 0.3]
SEQUENCE<DOUBLE> s13 = :s12 || :s12; -- s13 is [0.1, 0.2, 0.3, 0.1, 0.2, 0.3]  
SEQUENCE<SEQUENCE<DOUBLE>> s14 = [[0.1, 0.2]];
SEQUENCE<SEQUENCE<DOUBLE>> s15 = :s14 || [[0.3]]; -- s15 is [[0.1, 0.2], [0.3]]
SEQUENCE<SEQUENCE<DOUBLE>> s16 = :s15 || :s15; -- s16 is [[0.1, 0.2], [0.3], [0.1, 0.2], [0.3]]
s14 = :s14 || [0.3, 0.1]; -- s14 is [[0.1, 0.2], [0.3, 0.1]]
```  

### Comparison
Compares two sequences for equality using '==' or inequality using '!=' operator.  
```graphscript
SEQUENCE<INTEGER> s17 = [1, 2, 2, 3];
SEQUENCE<INTEGER> s18 = [1, 2, 2, 3];
SEQUENCE<INTEGER> s19 = [2, 1, 2, 3];
BOOL b1 = :s17 == :s18; -- b1 is true
BOOL b2 = :s17 == :s19; -- b2 is false
BOOL b3 = :s18 != :s19; -- b3 is true  
SEQUENCE<SEQUENCE<INTEGER>> s20 = [[1, 2], [2, 3]];
SEQUENCE<SEQUENCE<INTEGER>> s21 = [[2, 3], [1, 2]];
BOOL b4 = :s20 == [[1, 2], [2, 3]]; -- b4 is true
BOOL b5 = :s20 == :s21; -- b5 is false
```  

### Positional Access  
It is possible to access and modify any element of a sequence via its position, which is between 1L
and the size of the sequence.  
```graphscript
SEQUENCE<INTEGER> s22 = [1, 2, 3];
INTEGER a1 = :s22[1L]; -- a1 is 1
s22[3L] = 5; -- s22 is [1, 3, 5];  
SEQUENCE<SEQUENCE<INTEGER>> s23 = [[1], [2, 3]];
SEQUENCE<INTEGER> s24 = :s23[1L]; -- s24 is [1]
s23[2L] = [4, 5, 6]; -- s23 is [[1], [4, 5, 6]]
```  
In a nested sequence, it is possible to access and modify any element of a sequence in a nested
sequence via comma-separated positions. The first index refers to the sequence's position in a
nested sequence, and is between 1L and the size of the nested sequence. The second index refers to
the element's position in this sequence, and is between 1L and the size of this sequence.  
```graphscript
SEQUENCE<SEQUENCE<INTEGER>> s25 = [[1], [2, 3]];
INTEGER a2 = :s25[2L,1L]; -- a2 is 2
s25[2L,2L] = 4;  -- s25 is [[1], [2, 4]];
```  
"
132;95;60;30;10;060-030-010-Multiset.md;MULTISET;Functions;"
### COUNT  
Returns the size of the given multiset. The result type is BIGINT.  
```graphscript
MULTISET<DOUBLE> m15 = {0.0, 0.1, 0.2};
BIGINT m15count = COUNT(:m15); -- m15count is 3L  
MULTISET<MULTISET<DOUBLE>> m16 = {{0.0, 0.1}, {0.2}};
BIGINT m16count = COUNT(:m16); -- m16count is 2L
```  

### DISTINCT  
Returns a multiset containing unique elements from the given multiset.  
```graphscript
MULTISET<BIGINT> m11 = {2L, 2L, 1L};
MULTISET<BIGINT> m12 = DISTINCT(:m11); -- m12 is {2L, 1L}  
MULTISET<MULTISET<BIGINT>> m13 = {{2L, 2L}, {1L, 3L}, {3L, 1L}};
MULTISET<MULTISET<BIGINT>> m14 = DISTINCT(:m13); -- m14 is {{2L, 2L}, {3L, 1L}}
```  

### IS_EMPTY  
Returns true if the multiset has no elements.  
```graphscript
MULTISET<DOUBLE> nonEmptyMS = {0.0, 0.1, 0.2};
BOOL b1 = IS_EMPTY(:nonEmptyMS); -- b1 is FALSE  
MULTISET<DOUBLE> emptyMS;
BOOL b2 = IS_EMPTY(:emptyMS); -- b2 is TRUE  
```  

### RANDOM_ELEMENT  
Returns a randomly chosen element from the given multiset.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX random_vertex = RANDOM_ELEMENT(VERTICES(:g));
MULTISET<INT> ms = {1,2,3};
INT random_int = RANDOM_ELEMENT(:ms);
```  

### SEQUENCE  
Returns a sequence containing elements from the given multiset. The order of elements in the
resulting sequence is arbitrary. Returning a nested sequence from nested multisets is currently not
supported.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
MULTISET<VERTEX> mv = VERTICES(:g);
SEQUENCE<VERTEX> sv = SEQUENCE<VERTEX>(:mv);
```  

### TO_ORDINALITY_MAP
This function converts a SEQUENCE of MULTISET of VERTEX or EDGE to a
MAP with VERTEX or EDGE as the key and a BIGINT as the value. It
places the vertices or edges as keys in the map with the ordinalities of
their multiset as values. Keys that appear multiple times will be
ignored after they have been discovered the first time.
For a reverse operation that creates a SEQUENCE of MULTISET from a MAP,
see TO_GROUP_SEQUENCE.  
```graphscript
SEQUENCE<MULTISET<VERTEX>> groupSeq  = [{:v3, :v1, :v3}, {:v2}];
MAP<VERTEX, BIGINT> ordMap = TO_ORDINALITY_MAP(:groupSeq);
:mapCommunities1[:v1] == 0L; -- true
:mapCommunities1[:v2] == 1L; -- true
:mapCommunities1[:v3] == 0L; -- true
``  
"
133;187;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;DAYOFMONTH;"Extracts the day-of-month component from a DATE or TIMESTAMP value.  
- DAYOFMONTH(DATE) => INTEGER
- DAYOFMONTH(TIMESTAMP) => INTEGER  
"
134;143;60;50;50;060-050-050-Arithmetic_Expressions.md;Arithmetic Expressions;;"Arithmetic expressions are binary expressions that take two expressions and an arithmetic operator
and produce a result. Both expressions have to be of the same type.  
```
<arithmetic_op> ::= <plus> | <minus> | <asterisk> | <slash> | <modulo>
<arithmetic_expr> ::= <expr> <arithmetic_op> <expr>
```  
"
135;163;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;LOG;"- LOG(DOUBLE, DOUBLE) => DOUBLE  
"
136;262;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Arithmetic Expression;"```graphscript
2 + 3
3 - 1
2 * :v.weight
2 / 2
```  
"
137;67;60;20;50;060-020-050-Basic_Weighted_Path_Operations.md;Basic Weighted Path Operations;LENGTH;"Calculates the length (number of edges) for a WEIGHTEDPATH.  
- LENGTH(WEIGHTEDPATH<BIGINT>) => BIGINT
- LENGTH(WEIGHTEDPATH<INTEGER>) => INTEGER
- LENGTH(WEIGHTEDPATH<DOUBLE>) => DOUBLE  
"
138;33;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;Definition Statements;"A definition statement declares and defines a local variable of a specific type.
Objects of primitive types are default-initialized to NULL.
Additionally, itâ€™s possible to do this explicitly by using NULL.
Vertices, edges, and graphs have to be initialized in the declaration.
A variable is visible and accessible in the current scope and all inner scopes, such as in loops and
conditional statements. Variables defined inside loops and conditional statements arenâ€™t accessible
outside the statements. GraphScript doesnâ€™t support variable shadowing; in other words, a variable
defined in an outer scope canâ€™t be redefined in an inner scope.  
```bnf
<definition> ::= <vertex_or_edge> <variable> = <expression> ;
| <primitive_type> <variable> [ = <expression> ] ;
| <primitive_type> <variable> NULL ;
| <graph> <variable> = <expression> ;
| <multiset_type> <variable> = <expression> ;
| <sequence_type> <variable> = <expression> ;
```  

### Examples  
```graphscript
GRAPH g1 = GRAPH(""FLIGHTS"",""GRAPH"");
GRAPH g2 = GRAPH(""GRAPH"");
GRAPH g3 = GRAPH(mygraph);
VERTEX v(:g1,1);
EDGE e(:g1,'3');
INTEGER i;
DOUBLE d = 23.5;
NVARCHAR s = 'Dave';
```  
"
139;55;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;OUT_EDGES;"Returns all the outgoing edges of a vertex.  
- OUT_EDGES(VERTEX) => MULTISET  
<!--! section id=""section_ebf_nqc_1hb"" -->"
140;155;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;BITXOR;"- BITXOR(INTEGER,INTEGER) => INTEGER
- BITXOR(BIGINT,BIGINT) => BIGINT  
"
141;165;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;ROUND;"- ROUND(INTEGER) => INTEGER
- ROUND(INTEGER, INTEGER) => INTEGER
- ROUND(BIGINT) => BIGINT
- ROUND(BIGINT, INTEGER) => BIGINT
- ROUND(DOUBLE) => DOUBLE
- ROUND(DOUBLE, INTEGER) => DOUBLE  
"
142;193;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;ADD_MINUTES;"Computes the specified TIMESTAMP value, plus or minus the specified minutes. The value to be added
or subtracted needs to be an INTEGER.  
- ADD_MINUTES(TIMESTAMP, INTEGER) => TIMESTAMP  
"
143;247;90;20;0;090-020-000-Appendix_A_-_Open_Flights_Graph_Example.md;Appendix A - Open Flights and Company Graph Examples;Company Graph Example;"Use the following SQL statements to create the Company graph example.  

### Create Vertex and Edge Tables (Company)  
```sql
DROP SCHEMA COMPANY_SCHEMA CASCADE;
CREATE SCHEMA COMPANY_SCHEMA;
SET SCHEMA COMPANY_SCHEMA;  
CREATE TABLE EMPLOYEES(EID NVARCHAR(10) PRIMARY KEY, FIRST_NAME NVARCHAR(100), LAST_NAME NVARCHAR(100));
INSERT INTO EMPLOYEES VALUES ('I123456', 'John',  'May');
INSERT INTO EMPLOYEES VALUES ('I123457', 'Paul',  'Evans');
INSERT INTO EMPLOYEES VALUES ('D123456', 'Maria', 'Peters');  
CREATE TABLE PROJECTS(PID INTEGER PRIMARY KEY, NAME NVARCHAR(50), BUDGET BIGINT);
INSERT INTO PROJECTS VALUES (1, 'HANA', 500000);
INSERT INTO PROJECTS VALUES (2, 'DWC',  450000);  
CREATE TABLE PRODUCTS(PID INTEGER PRIMARY KEY, NAME NVARCHAR(50), PRICE INTEGER);
INSERT INTO PRODUCTS VALUES (100, 'SAP HANA Platform',        300);
INSERT INTO PRODUCTS VALUES (101, 'SAP HANA Cloud',           400);
INSERT INTO PRODUCTS VALUES (200, 'SAP Data Warehouse Cloud', 500);  
CREATE TABLE CUSTOMERS(CID BIGINT PRIMARY KEY, COMPANY_NAME NVARCHAR(100), ADDRESS NVARCHAR(200));
INSERT INTO CUSTOMERS VALUES (1, 'XYZ Corp', 'Address XYZ Corp');
INSERT INTO CUSTOMERS VALUES (2, 'ABC Inc',  'Address ABC Inc');  
CREATE TABLE PROJECT_ASSIGNMENTS(
EMPLOYEE_ID NVARCHAR(10) REFERENCES EMPLOYEES(EID),
PROJECT_ID INTEGER REFERENCES PROJECTS(PID),
HOURS SMALLINT,
PRIMARY KEY (EMPLOYEE_ID, PROJECT_ID));
INSERT INTO PROJECT_ASSIGNMENTS VALUES ('I123456', 1, 300);
INSERT INTO PROJECT_ASSIGNMENTS VALUES ('I123457', 1, 400);
INSERT INTO PROJECT_ASSIGNMENTS VALUES ('I123456', 2, 100);
INSERT INTO PROJECT_ASSIGNMENTS VALUES ('D123456', 2, 400);  
CREATE TABLE PROJECT_OUTCOMES(
PROJECT_ID INTEGER REFERENCES PROJECTS(PID),
PRODUCT_ID INTEGER REFERENCES PRODUCTS(PID),
PRIMARY KEY (PROJECT_ID, PRODUCT_ID));
INSERT INTO PROJECT_OUTCOMES VALUES (1, 100);
INSERT INTO PROJECT_OUTCOMES VALUES (1, 101);
INSERT INTO PROJECT_OUTCOMES VALUES (2, 200);  
CREATE TABLE SALES(
PRODUCT_ID INTEGER REFERENCES PRODUCTS(PID),
CUSTOMER BIGINT REFERENCES CUSTOMERS(CID),
UNITS INTEGER,
PRIMARY KEY (PRODUCT_ID, CUSTOMER));
INSERT INTO SALES VALUES (100, 1, 3);
INSERT INTO SALES VALUES (101, 1, 2);
INSERT INTO SALES VALUES (200, 2, 7);
```  

### Create Graph Workspace (Company)  
```sql
CREATE GRAPH WORKSPACE COMPANY_GRAPH
VERTEX TABLE EMPLOYEES
KEY EID
LABEL 'Employee'
VERTEX TABLE PROJECTS
LABEL 'Project'
KEY PID
EDGE TABLE PROJECT_ASSIGNMENTS
SOURCE EMPLOYEE_ID REFERENCES EMPLOYEES
TARGET PROJECT_ID REFERENCES PROJECTS
KEY EMPLOYEE_ID, PROJECT_ID
LABEL 'Assignments'
EDGE TABLE PROJECT_OUTCOMES
KEY PROJECT_ID, PRODUCT_ID
SOURCE PROJECT_ID REFERENCES PROJECTS
TARGET PRODUCT_ID REFERENCES PRODUCTS
VERTEX TABLE PRODUCTS
KEY PID
LABEL 'Product'
VERTEX TABLE CUSTOMERS
KEY CID
EDGE TABLE SALES
KEY PRODUCT_ID, CUSTOMER
LABEL 'Sales'
SOURCE PRODUCT_ID REFERENCES PRODUCTS
TARGET CUSTOMER REFERENCES CUSTOMERS;
```"
144;146;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;ABS;"- ABS(INTEGER) => INTEGER
- ABS(BIGINT) => BIGINT
- ABS(DOUBLE) => DOUBLE  
"
145;48;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;VERTEX_EXISTS;"Checks if the given vertex, or a vertex with the given (composite) vertex key exists in a graph or a weighted
path. If multiple vertex tables are defined in the graph workspace, it is mandatory to provide a label for the
check by key. The label comes directly after the graph or path variable.  
- VERTEX_EXISTS(GRAPH, VERTEX) => BOOL
- VERTEX_EXISTS(GRAPH, NVARCHAR, scalar_key_type[,scalar_key_type]) => BOOL
- VERTEX_EXISTS(WEIGHTEDPATH, VERTEX) => BOOL
- VERTEX_EXISTS(WEIGHTEDPATH, NVARCHAR, scalar_key_type[,scalar_key_type]) => BOOL  
In the case that only a single vertex table is defined, the label can be omitted.  
- VERTEX_EXISTS(GRAPH, scalar_key_type[,scalar_key_type]) => BOOL
- VERTEX_EXISTS(WEIGHTEDPATH, scalar_key_type[,scalar_key_type]) => BOOL  
"
146;112;60;40;0;060-040-000-Table_Operations.md;Table Operations;Cell Read Access;"Reads the value at a certain index position of a specified table column.
Returns NULL if the desired cell index is larger than the row count of the table.
The index is 1-based, i.e., the first element is accessed with the index number 1L.  
```graphscript
INTEGER i = :tab.""IntColumn""[1L];
```  
"
147;37;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;FOREACH Loops;"A FOREACH loop iterates over all elements in a container (Multiset, Sequence or Map). The iteration
order is not specified and might differ between two script executions. The iteration variables
defined in the loop head, e.g., element value, are scoped to the loop body and therefore are not
available in the outside scope. Furthermore, all iteration variables are read-only, i.e., new
values cannot be assigned to them. Similarly, when iterating over a named container, assignments to
the container variable are not allowed in the loop body.  
The special loop statements BREAK and CONTINUE are only available inside a loop body. BREAK stops
the loop execution and CONTINUE skips to the next iteration.  
Multiset and Sequence consist of single-value elements. One iteration variable must be defined
before the IN keyword to refer to the element which is processed in the current iteration. The
expression following the IN keyword must evaluate to a Multiset or Sequence container. For
Sequences, a second iteration variable can be optionally defined. It refers to the ordinal position
of the element inside the Sequence.  
Maps contain key-value pairs. Hence, two iteration variables must be defined before the IN keyword.
They refer to the key and value part of an element pair, respectively.  
```bnf
<foreach_loop> ::= FOREACH <variable> IN <expr> [WITH ORDINALITY AS <variable>] '{' <statements> '}'
| FOREACH '(' <variable> ',' <variable> ')' IN <expr> '{' <statements> '}'
```  

### Examples  
```graphscript
GRAPH g = GRAPH(""MYWORKSPACE"");
INT sumVal = 0;
FOREACH v IN VERTICES(:g) {
sumVal = :sumVal + :v.attr;
}  
SEQUENCE<VERTEX> seq = [ VERTEX(:g,1), VERTEX(:g,2) ];
FOREACH v IN :seq WITH ORDINALITY AS ord {
v.positionAttr = :ord;
}  
MAP<VERTEX,DOUBLE> costMap(:g, 1024L);
-- some code filling costMap
FOREACH (v,cost) IN :costMap {
-- iteration over vertex-cost pair of costMap assigned to variables v and cost
}
```  
"
148;248;90;30;0;090-030-000-Appendix_B_-_Notation.md;Appendix B - Notation;;"The syntactic notation used in this guide is an extended version of BNF (""Backus Naur Form"").  
In a BNF language definition, each syntactic element of the language (known as a BNF nonterminal
symbol) is defined by means of a production rule. This rule defines the element in terms of a
formula consisting of the characters, character strings, and syntactic elements that can be used
to form an instance of the formula.  
The following table explains the symbols used and their meanings:  
|Symbol|Meaning|
|---|------|
|<>|A character string enclosed in angle brackets is the name of a syntactic element (BNF nonterminal) of the GraphScript language.|
|::=|The definition operator is used in a production rule to separate the element defined by the rule from its definition. The element being defined appears to the left of the operator and the formula that defines the element appears to the right.|
|[ ]|Square brackets indicate optional elements in a formula. The portion of the formula within the brackets can be explicitly specified or can be omitted.|
|{}|Braces group elements in a formula. Curly braces indicate that the expression can be repeated zero or more times.|
|\pipe|The alternative operator. The vertical bar indicates that the portion of the formula following the bar is an alternative to the portion preceding the bar. If the vertical bar appears at a position where it isn't enclosed in braces or square brackets, it specifies a complete alternative for the element defined by the production rule. If the vertical bar appears in a portion of a formula enclosed in braces or square brackets, it specifies alternatives for the contents of the innermost pair of these braces or brackets.|
|!!|Introduces normal English text. This is used when the definition of a syntactic element isn't expressed in BNF.|
|-|The minus operator. The horizontal bar excludes the result of the formula following the bar from valid rules that are defined in front of the bar. The scope of this operator is equivalent to the scope of the alternative operator.|  
Spaces are used to separate syntactic elements.
Multiple spaces and line breaks are treated as a single space.
Apart from those symbols with special functions (see previous table), other characters and character
strings in a formula stand for themselves. In addition, if the symbols to the right of the
definition operator in a production consist entirely of BNF symbols, then these symbols stand for
themselves and don't take on their special meaning.  
Pairs of braces and square brackets can be nested to any depth, and the alternative operator can
appear at any depth within such a nest.  
A character string, which forms an instance of any syntactic element, can be generated from the BNF
definition of that syntactic element by performing the following steps:  
- Select any one option from those defined in the right-hand side of a production rule for the element and replace the element with this option.
- Replace each ellipsis, and the object it applies to, with one or more instances of that object.
- For every portion of the string enclosed in square brackets, either delete the brackets and their contents or change the brackets to braces.
- For every portion of the string enclosed in braces, apply steps 1 through 5 to the substring between the braces, then remove the braces.
- Apply steps 1 through 5 to any BNF nonterminal symbol that remains in the string.  
The expansion or production is complete when no further nonterminal symbols remain in the
character string.  
By applying the previous steps 1 through 5 to NT, and always selecting the leftmost BNF
nonterminal in step 5, the left normal form derivation of a character string CS in the source
language character set from a BNF nonterminal NT is obtained."
149;122;60;50;10;060-050-010-Numeric_Types.md;Numeric Types;DOUBLE;"The DOUBLE data type specifies a double-precision 64-bit floating-point number.  
- The minimum value is -1.7976931348623157E308 and the maximum value is 1.7976931348623157E308.
- The smallest positive DOUBLE value is 2.2250738585072014E-308 and the largest negative DOUBLE
value is -2.2250738585072014E-308.
- A variable of type DOUBLE is default-initialized with the value NULL."
150;64;60;20;50;060-020-050-Basic_Weighted_Path_Operations.md;Basic Weighted Path Operations;;"The WEIGHTEDPATH, like a subgraph, contains copies of the corresponding vertices and edges from the
parent graph that form a path. All vertices and edges of a WEIGHTEDPATH originate from the parent graph
but are different objects. A vertex or edge of a WEIGHTEDPATH has all persistent and temporary attributes
of a vertex or edge in the parent graph at the time of path creation. Modifications of temporary
attributes in the parent graph arenâ€™t propagated to the corresponding temporary attributes of a
WEIGHTEDPATH and the other way around.  
"
151;71;60;20;50;060-020-050-Basic_Weighted_Path_Operations.md;Basic Weighted Path Operations;Temporary Attributes;"Temporary attributes are defined on graphs. Paths and weighted paths are views on the graph they are based on.
They inherit all temporary attributes from the graph, and changes to temporary attributes done on the path are
visible on the graph and vice versa.  

### Examples  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(VERTEX INTEGER distance = 0, VERTEX DOUBLE price = 0.0);
VERTEX v_source(:g, 'FRA');
VERTEX v_target(:g, 'JFK');
v_target.price = 32.8;
WEIGHTEDPATH<BIGINT> p = SHORTEST_PATH(:g, :v_source, :v_target);
VERTEX p_source(:p, 'FRA');
p_source.distance = 7; -- now also v_source.distance is 7
DOUBLE target_price = :v_target.price; -- is 32.8 as set on the original graph
```"
152;58;60;20;40;060-020-040-Basic_Edge_Operations.md;Basic Edge Operations;Constructors;"Constructs a [edge](loio2c67724259aa42879d871b289098e86c) reference from a graph or a weighted path, a label and a (composite) key. If
multiple edge tables are defined in the graph workspace, it is mandatory to provide a label in the
edge constructor. The label comes directly after the graph or path variable
and right before the key components (scalar_key_type) in the argument list of the EDGE constructor.
If no edge with the given key exists, then the program terminates with an error.
Use the EDGE_EXISTS function to determine whether a edge exists.  
- EDGE(GRAPH, NVARCHAR, scalar_key_type[,scalar_key_type]) => EDGE
- EDGE(WEIGHTEDPATH, NVARCHAR, scalar_key_type[,scalar_key_type]) => EDGE  
In the case that only a single edge table is defined, the label can be omitted.  
- EDGE(GRAPH, scalar_key_type[,scalar_key_type]) => EDGE
- EDGE(WEIGHTEDPATH, scalar_key_type[,scalar_key_type]) => EDGE  
A special case is the construction of an edge from a compatible edge. Edges are compatible if
their host graphs are defined in the same graph workspace, e.g., a weighted path, a subgraph and
an inversed graph are compatible with the graph they are constructed from, as they all share the
same graph workspace.  
- EDGE(GRAPH, EDGE) => EDGE
- EDGE(WEIGHTEDPATH, EDGE) => EDGE  
"
153;256;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;FOREACH Loop;"Iterate over all vertices in graph g:  
```graphscript
FOREACH v IN VERTICES(:g) { ... }
```  
Iterate over all edges in graph g:  
```graphscript
FOREACH e IN EDGES(:g) { ... }
```  
"
154;124;60;50;20;060-050-020-Non-Numeric_Scalar_Types.md;Non-Numeric Scalar Types;String Type;"The NVARCHAR character string data type specifies character strings of variable length. It's used
both for storing ASCII and Unicode character strings. A string variable  is default-initialized with
value NULL.  
"
155;230;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;TOBOOLEAN;"The TOBOOLEAN() function takes an integer, boolean or a string value and converts it to a boolean
value.  
```bnf
<toboolean_function> ::= TOBOOLEAN '(' <variable_name> '.' <attribute_name> ')'
```  
TOBOOLEAN(NULL) returns NULL. An error is thrown if the parsing fails.  
<!--! section id=""_"" -->"
156;60;60;20;40;060-020-040-Basic_Edge_Operations.md;Basic Edge Operations;LABEL;"Returns the label of a given edge. If no label was specified for a edge table in the graph
workspace, the name of the table is returned.  
- LABEL(Edge) => NVARCHAR  
"
157;120;60;50;10;060-050-010-Numeric_Types.md;Numeric Types;INTEGER;"The INTEGER data type specifies a 32-bit signed integer.  
- The minimum value is -2,147,483,648.
- The maximum value is 2,147,483,647.
- Integer literals that aren't suffixed with an 'L' are treated as 32-bit integer literals.
- A variable of type INTEGER is default-initialized with the value NULL.  
"
158;156;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;CEIL;"- CEIL(INTEGER) => INTEGER
- CEIL(BIGINT) => BIGINT
- CEIL(DOUBLE) => DOUBLE  
"
159;62;60;20;40;060-020-040-Basic_Edge_Operations.md;Basic Edge Operations;TARGET;"Returns the target vertex of an edge.  
- TARGET(EDGE) => VERTEX  
<!--! section id=""section_ebf_nqc_1hb"" -->"
160;19;40;40;0;040-040-000-Graph_Metadata_Views.md;Graph Metadata Views;GRAPH_WORKSPACES System View;"This system view lists all existing graph workspaces.  

### Structure  
|Column name|Data type|Description|
|---|---|---|
|SCHEMA_NAME|NVARCHAR(256)|The name of the schema that the workspace resides in.|
|WORKSPACE_NAME|NVARCHAR(256)|The name of the workspace.|
|CREATE_TIMESTAMP|TIMESTAMP|The workspace creation timestamp.|
|USER_NAME|NVARCHAR(256)|The username of the workspace creator.|
|IS_VALID|NVARCHAR(5)|Specifies whether this workspace is valid (TRUE or FALSE).|  
"
161;126;60;50;20;060-050-020-Non-Numeric_Scalar_Types.md;Non-Numeric Scalar Types;Datetime Type;"The TIMESTAMP data type consists of date and time information.  
- Its default format is `'YYYY-MM-DD HH24:MI:SS.FF7'`.
- FFn represents the fractional seconds where n indicates the number of digits in the fractional
part.
- The range of the time stamp value is between `0001-01-01 00:00:00.0000000` and
`9999-12-31 23:59:59.9999999`.
- A variable of type TIMESTAMP is default-initialized with NULL.  
"
162;244;90;0;0;090-000-000-Additional_Information.md;Additional Information;;This section provides additional information about syntax and examples.
163;260;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Attribute Access;"```graphscript
INTEGER a = :v.attr;
v.attr = 23;
```  
"
164;84;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Shortest Paths One-to-All;"```
<spoa_function> ::= SHORTEST_PATHS_ONE_TO_ALL '(' <parent_graph_variable>,
<source_vertex>, <distance_attribute_name> [ , <clos_expr> ] [ , <edge_direction> ] ')'  
<parent_graph_variable> ::= <variable_reference>
<start_vertex> ::= <expr>
<distance_attribute_name> ::= <identifier>
<edge_direction> ::= <expr>
```  
Returns a subgraph of the given parent graph (first parameter) built from the shortest paths from
the start vertex (second parameter) to all other reachable vertices.  
It contains all the attributes
from the parent graph and an additional vertex attribute (third parameter) containing the distance
from the start vertex to each reachable vertex. The type of the distance attribute is either BIGINT
or the return type of the optional weight function. By default, the weight metric of the
SHORTEST_PATHS_ONE_TO_ALL built-in function is the hop distance, that is, the number of edges on the
path, but itâ€™s also possible to supply a custom weight function (optional fourth parameter).
For details on the weight function, see
[Shortest Path](loio3b0a971b129c446c9e40a797bdb29c2b/section_shortest_path).  
The optional edge_direction parameter can be used to control how the direction of the edges of the
input graph is treated by the shortest path search. By default, the algorithm processes edges
according to their original direction as given in the input graph.
For possible values and discussion of
the edge direction parameter, see
[Shortest Path](loio3b0a971b129c446c9e40a797bdb29c2b/section_shortest_path).  
The resulting subgraph is a tree, that is, a directed, acyclic graph where each vertex has only one
incoming edge, except for the start vertex, which has no incoming edge.  

### Examples  
The following example demonstrates the usage of the SHORTEST_PATHS_ONE_TO_ALL function.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX dubai(:g, 'DXB');
GRAPH all_dubai_flights = SHORTEST_PATHS_ONE_TO_ALL(:g, :dubai, ""hop_distance_from_Dubai"");
```  
The following example demonstrates the use of custom weight functions of various types.
The first graph is constructed using a weight function depending on a temporary edge attribute. The
second graph uses a fixed constant weight. The third graph is based on a non-temporary edge
attribute.  
```graphscript
GRAPH G = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(EDGE INTEGER costs = 1);
VERTEX v_source(:G, 'FRA');
GRAPH cheapest = SHORTEST_PATHS_ONE_TO_ALL(
:g, :v_source, ""total_costs"",  (EDGE e) => INTEGER { RETURN :e.costs; });
GRAPH shortest_hop = SHORTEST_PATHS_ONE_TO_ALL(
:g, :v_source, ""hop_distance"",  (EDGE e) => BIGINT{ RETURN 1L; });
GRAPH shortest_total = SHORTEST_PATHS_ONE_TO_ALL(
:g, :v_source, ""total_distance"",  (EDGE e) => DOUBLE{ RETURN :e.""DIST_KM""; });
```  
The following example demonstrates the use of weight and hop distance bound inside a weight
function. The IF clause adds the bounds conditions and returns the subgraph with shortest paths to
all reachable vertices, where every path has a distance of less than 1000 kms and stopovers are less
than 2.  
```graphscript
GRAPH G = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX v_source(:G, 'FRA');
GRAPH bound_hierarchy = SHORTEST_PATHS_ONE_TO_ALL(
:g, :v_source, ""total_distance"",  (EDGE e, DOUBLE w, BIGINT h) =>
DOUBLE{ IF(:w + :e.""DIST_KM"" < 1000.0 AND :h + 1L < 2L){RETURN :e.""DIST_KM"";}
ELSE{END TRAVERSE;}});
```  
The following example demonstrates how to use the edge direction parameter to let the
SHORTEST_PATHS_ONE_TO_ALL function work as if it was operating on a graph with undirected edges.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX v_source(:g, 'AMS');
GRAPH any_hierarchy = SHORTEST_PATHS_ONE_TO_ALL(:g, :v_source, ""hop_distance"", 'ANY');
```  
"
165;222;70;20;10;070-020-010-Match_Clause.md;MATCH Clause;Topological Constraints;"Topological constraints are a comma-separated list of vertices and edges.
Additionally, one path can be used.  
```bnf
<topology_constraint> ::=
<vertex>
| <edge>
| <path>
```  

### Pattern for vertices  
The simplest pattern consists of a single vertex variable enclosed in parentheses. Additionally, a
vertex label can also be provided.  
```bnf
<vertex> ::= <l_paren> <variable_name> <r_paren>
| <l_paren> <variable_name> <colon> <label_name> <r_paren>
```  
```OpenCypher
(a)
(a:vertex_label)
```  
The following query illustrates the pattern with a vertex label:  
```OpenCypher
MATCH (a:label) RETURN a.NAME AS name
```  

### Pattern for related vertices  
A pattern can consist of two vertices and an edge connecting them. In the following example,
vertices `a` and `b` are connected with an edge `e`. The direction of the relationship between the
vertices can be specified using an arrow `->`. Additionally, an edge label can also be provided.  
```bnf
<edge> ::= <source> <directed_edge> <target>
| <source> <undirected_edge> <target>
<directed_edge> ::= <minus> <edge_var> <minus> <greater>
<undirected_edge> ::= <minus> <edge_var> <minus>
<vertex_var> ::= <l_paren> <variable_name> <r_paren>
<edge_var> ::= <l_square> <variable_name> <r_square>
| <l_square> <variable_name> <colon> <label_name> <r_square>
```  
```OpenCypher
(a)-[e]-(b)               -- any edge
(a)-[e]->(b)              -- directed edge
(a)-[e:edge_label]-(b)    -- edge with label
```  
The following query illustrates the use of an undirected edge:  
```OpenCypher
MATCH (a)-[e]-(b)
WHERE a.NAME = 'John F Kennedy International Airport' RETURN b.NAME AS Name
ORDER BY b.NAME
```  
The result of this query is the following table:  
|Name|
|---|
|Amsterdam Airport Schiphol|
|Amsterdam Airport Schiphol|
|Dubai International Airport|
|Dubai International Airport|
|Frankfurt am Main Airport|
|Frankfurt am Main Airport|
|Indira Gandhi International Airport|
|Indira Gandhi International Airport|
|Philadelphia International Airport|
|Philadelphia International Airport|  
The following query illustrates the use of multiple MATCH clauses:  
```OpenCypher
MATCH (a)-[e1]->(b)
MATCH (b)-[e2]->(c)
WHERE a.NAME = 'Philadelphia International Airport' RETURN c.NAME AS Name
ORDER BY c.NAME
```  
This query returns all vertices laying at a distance of two hops from Philadelphia International
Airport, considering the direction of edges:  
|Name|
|---|
|Amsterdam Airport Schiphol|
|Dubai International Airport|
|Frankfurt am Main Airport|
|Indira Gandhi International Airport|
|Philadelphia International Airport|  
<!--! note -->
### Note  
Note that Philadelphia International Airport is also in the results, which means that edge variables
`e1` and `e2` match the same edge in the data graph. This would not be possible if `e1` and `e2` are
defined in the same MATCH clause.  
<!--! end-note -->  

### Pattern for Paths  
A pattern for path connects two vertices which are a variable number of hops away. The length of the
path must be specified using an asterisk, followed by the minimum path length, double dots and the
maximum path length `[*minimum_length..maximum_length]`. The minimal and maximal length of a
path must be in the range of 1 to 15. It is mandatory to assign this pattern to a path variable.
Additionally, the vertex labels and an edge label can also be provided.  
```bnf
<path> ::= <variable_name> <equal> <source> <directed_path> <target>
| <variable_name> <equal> <source> <undirected_path> <target>
<directed_path> ::= <minus> <l_square> <asterisk> <uint> <double_dot> <uint>
<r_square> <minus> <greater>
| <minus> <l_square> <colon> <label_name> <asterisk> <uint> <double_dot> <uint>
<r_square> <minus> <greater>
<undirected_path> ::= <minus> <l_square> <asterisk> <uint> <double_dot> <uint>
<r_square> <minus>
| <minus> <l_square> <colon> <label_name> <asterisk> <uint> <double_dot> <uint>
<r_square> <minus>
```  
```OpenCypher
MATCH p = (a)-[*1..2]->(b)
MATCH p = (a)-[:edge_label*1..2]->(b:vertex_label)
```  
The following query illustrates the use of a directed path:  
```OpenCypher
MATCH p = (a)-[*1..2]->(b)
WHERE a.NAME = 'Philadelphia International Airport'
RETURN b.NAME AS Name
ORDER BY b.NAME
```  
The path with the name `p` starts from vertex `a` and ends at vertex `b`. It is one or two edges
long. This query returns all vertices that are related to Philadelphia International Airport by
outgoing edges. The result is:  
|Name|
|---|
|Amsterdam Airport Schiphol|
|Dubai International Airport|
|Frankfurt am Main Airport|
|Indira Gandhi International Airport|
|John F Kennedy International Airport|
|Philadelphia International Airport|  
The following query illustrates the use of vertex labels and an edge label in a variable-length path
pattern, applied on a heterogenous graph `COMPANY_GRAPH`:  
```OpenCypher
MATCH p = (v1:Project)-[:Assignments*1..2]-(v2:Employee)
RETURN  v1.NAME AS Project_Name, [e IN RELATIONSHIPS(p) | e.PROJECT_ID] AS Project_ID,
v2.FIRST_NAME AS Employee_Name
ORDER BY v1.NAME')
```  
The above query returns the project vertices, the project IDs and the employees working on these
projects.  
|Project_Name|Project_ID|Employee_Name|
|---|---|---|
|DWC|[2]|Maria|
|DWC|[2]|John|
|HANA|[1]|Paul|
|HANA|[1]|John|  
<!--! section id=""section_hnv_gzg_4bb"" -->"
166;110;60;30;40;060-030-040-PriorityQueue.md;PRIORITYQUEUE;Functions;"
### COUNT  
Returns the number of entries stored in the priority queue. The result type is BIGINT.  
```graphscript
PRIORITYQUEUE<EDGE, INTEGER> priorityQueueIntEdge(:g);
PUSH(:priorityQueueIntEdge, :edge0, 2);
PUSH(:priorityQueueIntEdge, :edge1, 4);
BIGINT priorityQueueCount = COUNT(:priorityQueueIntEdge); -- priorityQueueIntEdgeCount is 2L
```  

### IS_EMPTY  
Returns true if the priority queue has no elements.  
```graphscript
PRIORITYQUEUE<EDGE, INTEGER> emptyPriorityQueue(:g);
BOOL b1 = IS_EMPTY(:emptyPriorityQueue); -- b1 is TRUE
PUSH(:emptyPriorityQueue, :edge0, 2);
BOOL b2 = IS_EMPTY(:emptyPriorityQueue); -- b2 is FALSE
```  

### FETCH  
Returns the element with the lowest priority value and removes it from the priority queue.
In case the priority queue is empty an exception is thrown.  
```graphscript
PRIORITYQUEUE<EDGE, INTEGER> priorityQueue1(:g);
PUSH(:priorityQueue1, :edge0, 2);
PUSH(:priorityQueue1, :edge1, 4);
EDGE edgeFirst = FETCH(:priorityQueue1); -- edgeFirst is edge1
EDGE edgeSecond = FETCH(:priorityQueue1); -- edgeSecond is edge0
BOOL b = IS_EMPTY(:priorityQueue1); -- b is TRUE
```  

### PUSH  
Inserts the element with the given priority into the priority queue.
In case the element is already
present an exception is thrown.  
```graphscript
PRIORITYQUEUE<EDGE, INTEGER> priorityQueue2(:g);
PUSH(:priorityQueue2, :edge0, 2); -- inserts edge0 with priority 2
PUSH(:priorityQueue2, :edge1, 4); -- inserts edge1 with priority 4
PUSH(:priorityQueue2, :edge1, 1); -- error since edge1 has already been inserted
```  

### GET_TOP_PRIORITY  
Returns the priority of the element with the lowest priority value.  
```graphscript
PRIORITYQUEUE<EDGE, INTEGER> priorityQueue3(:g);
PUSH(:priorityQueue3, :edge0, 2); -- inserts edge0 with priority 2
PUSH(:priorityQueue3, :edge1, 4); -- inserts edge1 with priority 4
INTEGER topWeight = GET_TOP_PRIORITY(:priorityQueue3); -- topWeight is 2
```"
167;149;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;ATAN;"- ATAN(DOUBLE) => DOUBLE  
"
168;179;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;CURRENT_TIMESTAMP;"Returns the current local system TIMESTAMP value.
This function is an analogue to the homonymous function in HANA SQL.  
It is recommended that you use UTC TIMESTAMP instead of local TIMESTAMP. See to the CURRENT_UTCTIMESTAMP function for more information.  
- CURRENT_TIMESTAMP() => TIMESTAMP  
"
169;277;90;50;0;090-050-000-Appendix_D_-_OpenCypher_Cheat_Sheet.md;Appendix C - openCypher Cheat Sheet;General Structure;"```sql
SELECT * FROM OPENCYPHER_TABLE( GRAPH WORKSPACE ""SCHEMA"".""GRAPH"" QUERY
` -- openCypher query goes here `
);
```  
An example:  
```sql
SELECT * FROM OPENCYPHER_TABLE( GRAPH WORKSPACE ""FLIGHTS"".""GRAPH"" QUERY
' MATCH (a)-[e]-(b)
WHERE a.NAME = ''John F Kennedy International''
RETURN b.NAME AS Name
ORDER BY b.NAME '
);
```  
"
170;5;40;0;0;040-000-000-Graph_Workspaces.md;Graph Workspaces;;"A graph workspace is a catalog object that defines a graph in terms of vertex tables and edge tables.  
A graph workspace consists of one or more vertex tables and one or more edge tables -
the same table can be used to specify both a vertex table and an edge table.
Vertex attributes with the same name, must have the same data type.
Similarly, edge attributes with the same name, must have the same data type.  
For each graph table an optional label can be specified.
If no label is specified, the label defaults to the corresponding vertex or edge table name.
Vertex labels and edge labels must be unique within a particular graph workspace.  
Each vertex is uniquely identified by its associated label and one or more vertex
attributes denoted as the vertex key attributes. Analogously, each edge is uniquely identified
by its label and one or more edge attributes denoted as the edge key attributes.  
All the source vertices defined in a specific edge table
must refer to vertices from the same vertex table of the given graph workspace.
Similarly, all the target vertices defined in a specific edge table
must refer to vertices from the same vertex table of the given graph workspace.
Consequently, if a graph workspace contains multiple vertex tables, then it is mandatory
to specify the vertex table referenced by the source and target vertices of each edge table.
The source and target vertex for each edge is uniquely identified by one or more edge attributes,
which are denoted source and target attributes, respectively.
The data type and order of the source and target attributes must match
the data type and order of the key attributes in the corresponding referenced vertex table.  
A graph workspace is uniquely identified by the database schema it resides in and the workspace
name. An SAP HANA instance can contain multiple graph workspaces in the same schema with different
workspace names or different database schemas.  
Graph workspace metadata information is provided by the system views GRAPH_WORKSPACES and
GRAPH_WORKSPACE_COLUMNS.  
<!--! related-links -->"
171;188;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;MONTH;"Extracts the month component from a DATE or TIMESTAMP value.  
- MONTH(DATE) => INTEGER
- MONTH(TIMESTAMP) => INTEGER  
"
172;176;60;50;70;060-050-070-String_Functions.md;String Functions;Concatenation;"String concatenation is a binary expression that takes two expressions and a concatenation operator
and produces a combined string value. Both expressions have to be of character string type.  
```bnf
<concat_op_expr> ::= <expr> '||' <expr>
```  

### Examples  
```graphscript
NVARCHAR str1 = 'Basket';
NVARCHAR str2 = 'ball';
NVARCHAR str3 = :str1 || :str2;
```"
173;89;60;20;70;060-020-070-Graph_Traversal_Statements.md;Graph Traversal Statements;Depth-First Search (DFS);"DFS follows one adjacent edge deeper into the graph as far as possible before backtracking.
In addition to the common hooks ON VISIT VERTEX and ON VISIT EDGE, it supports ON EXIT VERTEX as
well.
The VISIT hooks are executed when visiting the element the first time.
The EXIT VERTEX hook runs right before backtracking from the vertex.  
DFS does not support any other traversal directions than the default OUTGOING.
The start vertex must be a single vertex."
174;280;90;50;0;090-050-000-Appendix_D_-_OpenCypher_Cheat_Sheet.md;Appendix C - openCypher Cheat Sheet;OpenCypher functions;"
### TOBOOLEAN  
```OpenCypher
TOBOOLEAN(value)
```  
Converts the input to a boolean.  

### TOFLOAT  
```OpenCypher
TOFLOAT(value)
```  
Converts the input to a floating point number.  

### TOINTEGER  
```OpenCypher
TOINTEGER(value)
```  
Converts the input to an integer.  

### TOSTRING  
```OpenCypher
TOSTRING(value)
```  
Converts the input to a string.  

### DATETIME  
```OpenCypher
DATETIME(value)
```  
Converts the input to a datetime.  

### DATE  
```OpenCypher
DATE(value)
```  
Converts the input to a date.  

### RELATIONSHIPS  
```OpenCypher
RELATIONSHIPS(p)
```  
Takes a path variable and returns a collection of all edges in the path.  

### ALL  
```OpenCypher
WHERE ALL(e IN RELATIONSHIPS(path) WHERE e.DIST_KM > 8000.0)
```  
Returns true if the given condition is true for all elements in the given collection.  

### LABEL  
```OpenCypher
LABEL(v)
```  
Takes a vertex or an edge variable and returns its label.  

### SYS.TEXT_CONTAINS  
```OpenCypher
WHERE SYS.TEXT_CONTAINS(a.name,'Dubbai','FUZZY(0.8)')    -- fuzzy search
WHERE SYS.TEXT_CONTAINS(e.color,'b*','EXACT')            -- exact search
```  
Allows advanced text search capabilities."
175;11;40;10;0;040-010-000-Create_Graph_Workspace.md;CREATE GRAPH WORKSPACE Statement (Data Definition);Example;"Create the graph workspace ""COMPANY_GRAPH"". For the complete list of SQL statements
used to create the underlying tables of the `""COMPANY_GRAPH""` workspace please
see [Appendix A](loio071d7b7349f04e419507387c271dce8f/section_company_graph_example).  
```sql
CREATE GRAPH WORKSPACE COMPANY_GRAPH
VERTEX TABLE EMPLOYEES
KEY EID
LABEL 'Employee'
VERTEX TABLE PROJECTS
LABEL 'Project'
KEY PID
EDGE TABLE PROJECT_ASSIGNMENTS
SOURCE EMPLOYEE_ID REFERENCES EMPLOYEES
TARGET PROJECT_ID REFERENCES PROJECTS
KEY EMPLOYEE_ID, PROJECT_ID
LABEL 'Assignments'
EDGE TABLE PROJECT_OUTCOMES
KEY PROJECT_ID, PRODUCT_ID
SOURCE PROJECT_ID REFERENCES PROJECTS
TARGET PRODUCT_ID REFERENCES PRODUCTS
VERTEX TABLE PRODUCTS
KEY PID
LABEL 'Product'
VERTEX TABLE CUSTOMERS
KEY CID
EDGE TABLE SALES
KEY PRODUCT_ID, CUSTOMER
LABEL 'Sales'
SOURCE PRODUCT_ID REFERENCES PRODUCTS
TARGET CUSTOMER REFERENCES CUSTOMERS;
```  
The `""COMPANY_GRAPH""` contains multiple vertex tables. Therefore, for each edge table
the referenced source and target vertex table must be specified.
The label is a case-sensitive SQL string: For the edges contained in the `""SALES""` table,
the label is `'Sales'` whereas the vertices defined through the `""CUSTOMERS""` table
have the default label `'CUSTOMERS'`.  
For the Open Flights graph workspace example consisting of one vertex table and one edge table,
see [Appendix A](loio071d7b7349f04e419507387c271dce8f/section_open_flights_example)."
176;218;70;10;0;070-010-000-OPENCYPHER_TABLE_SQL_Function.md;OPENCYPHER_TABLE SQL Function;Examples;"The example is based on the Open Flights graph from section
[Appendix A - Open Flights Graph Example](loio071d7b7349f04e419507387c271dce8f).  
```sql
SELECT DISTINCT * FROM OPENCYPHER_TABLE( GRAPH WORKSPACE ""FLIGHTS"".""GRAPH"" QUERY
'
MATCH (a)-[e]-(b)
WHERE a.NAME = ''John F Kennedy International Airport'' RETURN b.NAME AS Name
ORDER BY b.NAME
'
) ORDER BY ""Name""
```  
|Name|
|---|
|Amsterdam Airport Schiphol|
|Dubai International Airport|
|Frankfurt am Main Airport|
|Indira Gandhi International Airport|
|Philadelphia International Airport|  
This example shows how to use parameters in the query above.  
```sql
SELECT DISTINCT * FROM OPENCYPHER_TABLE( GRAPH WORKSPACE ""FLIGHTS"".""GRAPH"" QUERY
'
MATCH (a)-[e]-(b)
WHERE a.NAME = $airport RETURN b.NAME AS Name
ORDER BY b.NAME
'
PARAMETERS ('airport'= ?)
)
```  
<!--! related-links -->"
177;263;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Logical Expressions;"```graphscript
(3 == 4) AND (4 == 3)
TRUE OR (:a.weight > 3)
NOT (3 == 2)
(:a.attr IS NULL) AND (:b.attr IS NOT NULL)
```  
"
178;153;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;BITNOT;"- BITNOT(INTEGER) => INTEGER
- BITNOT(BIGINT) => BIGINT  
"
179;171;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;SQRT;"- SQRT(DOUBLE) => DOUBLE  
"
180;162;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;LN;"- LN(DOUBLE) => DOUBLE  
"
181;180;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;CURRENT_UTCTIMESTAMP;"Returns the current UTC TIMESTAMP value.
This function is an analogue to the homonymous function in HANA SQL.  
- CURRENT_UTCTIMESTAMP() => TIMESTAMP  
"
182;66;60;20;50;060-020-050-Basic_Weighted_Path_Operations.md;Basic Weighted Path Operations;WEIGHT;"Calculates the weight for a WEIGHTEDPATH.  
- WEIGHT(WEIGHTEDPATH<BIGINT>) => BIGINT
- WEIGHT(WEIGHTEDPATH<INTEGER>) => INTEGER
- WEIGHT(WEIGHTEDPATH<DOUBLE>) => DOUBLE  
"
183;185;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;MINUTE;"Extracts the minute component from a TIMESTAMP value.  
- MINUTE(TIMESTAMP) => INTEGER  
"
184;239;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;SYS.TEXT_CONTAINS;"The function SYS.TEXT_CONTAINS makes advanced text search capabilities available in openCypher.  
```bnf
<text_contains_function> ::= TEXT_CONTAINS '('
<variable_name> '.' <attribute_name> ',' <varchar_constant> ',' <varchar_constant> ')'
```  
This function returns a Boolean result and can be used as a predicate in a WHERE clause of an
openCypher query.  
The first parameter is a vertex or directed edge attribute of type NVARCHAR.
The second parameter is a string literal that specifies the search pattern, and the third parameter
is a string literal specifying one of the two available search modes:
EXACT or FUZZY. The search pattern can contain reserved operators (-,?,"",*,OR,%) that
have special meanings, depending on the search mode.  
Here are two examples of how to apply the TEXT_CONTAINS function:  
```OpenCypher
MATCH (a)
WHERE SYS.TEXT_CONTAINS(a.name,'Dubbai','FUZZY(0.8)')
RETURN a.id
```  
```OpenCypher
MATCH (a)-[e]->(b)
WHERE SYS.TEXT_CONTAINS(e.color,'b*','EXACT')
RETURN a.id
```  
Additionally, the user can create a full-text index for any NVARCHAR column in the vertex or
edge table to transform the search into a full-text search.
More information about the full-text search and how to create a full-text index can be found in the
[SAP HANA Cloud Search Developer Guide](related_links) and in the
[SAP HANA Cloud SQL Reference Guide](related_links).  
There are the following limitations:  
- Undirected edges aren't supported.
- The function only supports graph workspaces on top of column store tables.
- The search pattern must not contain single quotes or brackets.  

### Exact search  
In the EXACT search mode, the search term must match the entire search pattern to return a column
entry as a match. In this search mode, the user can specify the search pattern as a complex
predicate using the following specific operators. Some operators are useful only in a full-text
search.  
- With a minus sign (-), SAP HANA searches in columns for matches that don't contain the term
immediately following the minus sign.
- The question mark (?) replaces a single character in a search term (for example, `cat?` would
match cats).
- Terms within the quotation marks ("" "") aren't tokenized and are handled as a string.
Therefore, all search matches must be exact.
- The or-operator (OR) matches contain at least one of the terms joined by the OR operator.
- The asterisk sign (*) replaces 0 or more characters in a search term (for example, `cat*`
would match cats and catalogs).
- The space operator ( ) matches contain both of the terms joined by a space operator.  
Examples for complex search patterns in the EXACT search mode are:  
```OpenCypher
SYS.TEXT_CONTAINS(a.color, 'red', 'EXACT')
SYS.TEXT_CONTAINS(a.color, '-red', 'EXACT')
SYS.TEXT_CONTAINS(a.color, 'red*', 'EXACT')
SYS.TEXT_CONTAINS(a.color, '?ed', 'EXACT')
SYS.TEXT_CONTAINS(a.color, 'red OR blue', 'EXACT')
SYS.TEXT_CONTAINS(a.color, 'red blue', 'EXACT')
SYS.TEXT_CONTAINS(a.color, '""red blue""', 'EXACT')
```  

### Fuzzy search  
Fuzzy search is a fast and fault-tolerant search feature in SAP HANA.
A fuzzy search returns records even if the search term contains additional or missing characters or
other types of spelling errors. The first parameter, the fuzzy score, defines how different the
search pattern can be. It is a floating-point number from 0 through 1 and the larger the number, the
less difference is allowed. Moreover, the fuzzy search mode takes many additional parameters that
define how the fuzzy score is calculated.  
```OpenCypher
SYS.TEXT_CONTAINS(a.name, 'Dubai', 'FUZZY(0.8)')
SYS.TEXT_CONTAINS(a.name, 'Dubai', 'FUZZY(0.8, option1=value1, option2=value2)')
```  
A fuzzy search for 'Dubai' with an appropriate fuzzy score also returns vertices containing the
word 'Dubbai' or 'Dubay'. This provides the user the possibility to query dirty data, for example,
querying misspelled names.  
The following table shows a few additional options to influence fuzzy search results.
Many options conflict with each other or need to be combined with different options.
For more detailed information about these options and additional options,
see the [SAP HANA Cloud Search Developer Guide](related_links).  
|OPTIONS|VALUES|DESCRIPTION|
|---|---|---|
|similarCalculationMode|typeahead, symmetricsearch, substringsearch, searchcompare, search, compare|Defines the impact of wrong characters, additional characters in search patterns, and additional characters in data for the fuzzy score|
|termMappingTable|unquoted sql identifier|Defines terms that are used to extend a search to generate additional results|
|searchMode|alphanum, housenumber, postcode|Searches for special formats|  
<!--! related-links -->"
185;281;100;0;0;100-000-000-Important_Disclaimer_for_Features_in_SAP_HANA_Platform.md;Important Disclaimer for Features in SAP HANA;;"Some SAP HANA features and capabilities mentioned in this document may not be applicable in the SAP
HANA Cloud context.  
For information about the capabilities available for your contract type and provisioning scenario,
refer to the [Feature Scope Description for SAP Cloud Platform, SAP HANA Cloud](https://help.sap.com/viewer/5b0a45d84713461084c26b6a31533fd0/cloud/en-US) ."
186;206;60;50;90;060-050-090-Boolean_Expressions.md;Boolean Expressions;IS NULL Expressions;"The unary IS NULL and IS NOT NULL expressions allow you to check whether a scalar value or attribute
have the value NULL. The return type of the expressions is a Boolean value.  
```
<is_null_expression> ::= <expr> IS NULL
<is_not_null_expression> ::= <expr> IS NOT NULL
```  

### Examples  
```
INTEGER i; -- default initialization to NULL
BOOLEAN is_i_initialized = :i IS NOT NULL;
BOOLEAN is_weight_attr_null = :v.""weight"" IS NULL;
```"
187;204;60;50;90;060-050-090-Boolean_Expressions.md;Boolean Expressions;Relational Expressions;"Relational expressions are binary expressions that compare the values produced by two expressions
and return a BOOLEAN value. Both expressions must be of the same type. For VERTEX, EDGE, and BOOLEAN
types, only equality and inequality comparisons are allowed. For membership testing, the right
operand must be a multiset. Comparisons with NULL give a false result, that is, if both compared
values are NULL and the comparison operator is equals, the result is false.  
```bnf
<relational_op> ::= = | != | < | > | <= | >= | IN | NOT IN
<relational_expr> ::= <expr> <relational_op> <expr>
```  

### Examples  
```graphscript
:intValue > 3
(:doubleValue - 2.0 ) < 17
:v_current == VERTEX(:g, 'ID0001')
```  
"
188;21;40;50;0;040-050-000-Cache_Configuration.md;Global Cache Configuration;;"Depending on the cache specification in the CREATE GRAPH WORKSPACE statement, created graphs can be
temporarily kept in-memory for optimizing system responsiveness or for having temporarily stable
results. This section describes how to inspect the cache and globally modify its behavior.  
It is recommended that you do not change the default values, particularly on production systems,
as any changes may significantly affect overall system performance.  
The upper limit of memory that may be used by graph caching is defined as follows.
Both a relative percentage of the system memory and an absolute size in bytes are valid:  
```
ALTER SYSTEM ALTER CONFIGURATION ('indexserver.ini','SYSTEM')
SET ('graphengine', 'graph_cache_max_size') = '<amount_in_bytes|fraction_in_percent%>' WITH RECONFIGURE;
```  
The cache is checked periodically for an excess of this limit.
The least recently used entries are removed if they exceed the limit.
By default the interval for checking this limit is one hour and can be changed as follows:  
```
ALTER SYSTEM ALTER CONFIGURATION ('indexserver.ini', 'SYSTEM')
SET ('cache', 'reclaim_interval') = '<amount_in_seconds>' WITH RECONFIGURE;
```  
The 10 latest graph cache entries can be inspected as follows:  
```
SELECT TOP 10 * FROM m_cache_entries WHERE cache_id = 'GraphCache'
ORDER BY create_time DESC;
```  
All current graph cache entries may be immediately evicted as follows:  
```
ALTER SYSTEM CLEAR CACHE ('GraphCache');
```  
<!--! related-links -->"
189;232;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;TOINTEGER;"The TOINTEGER() function takes a boolean, integer, floating point or a string value and converts it
to an integer.  
```bnf
<tointeger_function> ::= TOINTEGER '(' <variable_name> '.' <attribute_name> ')'
```  
TOINTEGER(NULL) returns NULL. An error is thrown if the parsing fails.  
The following example shows how to use the TOINTEGER function.  
```OpenCypher
MATCH (a)-[e]->(b)
WHERE a.NODE_KEY = ''FRA'' AND b.NODE_KEY = ''PEK''
RETURN TOINTEGER(e.DIST_KM) as Distance
```  
|Distance|
|---|
|7808|  
<!--! section id=""_"" -->"
190;81;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Neighbors;"Explores the vicinity of a given set of start vertices with a distance window and
optional edge direction.  
```bnf
<neighbors_function> ::=
NEIGHBORS '(' <parent_graph_variable>, <start_vertices>,
<lower_bound>, <upper_bound> [, <edge_direction>] ')'  
<parent_graph_variable> ::= <variable_reference>
<start_vertices> ::= <expr>
<lower_bound> ::= <expr>
<upper_bound> ::= <expr>
<edge_direction> ::= <expr>
```  
Start vertices can be either a single vertex expression, or expressions returning a multiset or
sequence of vertices.  
In the following section, we define the distance of a vertex V to the start_vertices set as the
length (counted in hops) of the shortest of all paths from any member of the start_vertices set to
V.  
For non-negative lower_bound and upper_bound values, the NEIGHBORS function returns any vertex whose
distance to the start_vertices set isnâ€™t smaller than the lower_bound value and not larger than the
upper_bound value.  
The optional edge direction parameter can be used to specify which edges the algorithm traverses
when evaluating the distance of a vertex to the start_vertices set. The following values are
possible:  
'OUTGOING' traverses the edges as given in the input graph.
'INCOMING' traverses the edges of the input graph in reverse direction.
'ANY' traverses the input graph as if it was undirected.  
When the optional direction parameter isnâ€™t used, negative lower_bound and/or upper_bound values
compute the result as described following:  
- If both lower_bound and upper_bound are negative, that is, `NEIGHBORS(:g, :v, -a, -b)` is called,
the function computes the distance processing the edges in reverse direction and adjusted
interval borders:
`NEIGHBORS(:g, :v, -a, -b)` returns the same result as `NEIGHBORS(:g, :v, b, a, 'INCOMING')` .  
- If lower_bound is negative and upper_bound is non-negative, that is, `NEIGHBORS(:g, :v, -a, b)` is
called, then edges are traversed in both outgoing direction (up to b hops) and in incoming
direction (up to a hops). `NEIGHBORS(:g, :v, -a, b)` returns
`NEIGHBORS(:g, :v, a, 0) UNION NEIGHBORS(:g, :v, 1, b)` .  
The computation performed in the example of the INVERSEGRAPH function can be rewritten using a
single NEIGHBORS call with a corresponding distance range:  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
MULTISET<VERTEX> neighborsFrankfurt = NEIGHBORS(:g, [ VERTEX(:g, 'FRA') ], -1, 1);
```  
If the direction parameter is used, negative bound values are treated as 0. Any bounds interval for
which the upper bound is smaller than the lower bound returns an empty result.  
<!--! section id=""section_pagerank"" -->"
191;51;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;OUT_DEGREE;"Returns the number of outgoing edges of a vertex.  
- OUT_DEGREE(VERTEX) => BIGINT  
"
192;167;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;POWER;"- POWER(DOUBLE, DOUBLE) => DOUBLE  
"
193;224;70;20;20;070-020-020-Return_Clause.md;RETURN Clause;;"The RETURN clause lists expressions over the matched subgraphs that need to be projected into the
resulting table. The optional DISTINCT specifier eliminates duplicate rows from the resulting table.
The optional ORDER BY clause allows you to sort the resulting rows in ascending or descending order.
The optional LIMIT clause of the RETURN clause truncates the resulting table to the given number of
rows (from the top) if the result has more rows than the given number. Otherwise, all the rows are
displayed. The optional SKIP clause excludes the given number of rows from the top of the result.
When all three optional clauses are present, the ORDER-BY clause is applied first, then the SKIP
clause, and finally the LIMIT clause.  
```bnf
<return_clause> ::= RETURN [ DISTINCT ] <return_list>
[<order_by_clause>] [<limit_skip_clause>]  
<return_list> ::= <return_item> [{<comma> <return_item>}]
<return_item> ::= <return_expression> AS <alias>
<alias> ::= <identifier>  
<return_expression ::=
<attribute_access>
| <string_concatenation>
| <aggregate_function> <l_paren> <attribute_access> <r_paren>
| <list_comprehension>
| <object_constructor>  
<aggregate_function> ::= COUNT | MAX | MIN | SUM
<order_by_clause> ::= ORDER BY <order_by_list>
<order_by_list> ::= <order_by_item> [{<comma> <order_by_item>}]
<order_by_item> ::= <variable_name> <dot> <attribute_name> [ ASC | DESC ]  
<list_comprehension> ::= <l_square> <variable_name> IN
<relationships_function> <pipe> <expression> <r_square>
<object_constructor> ::= <l_curly> <identifier> <colon> <expr>
[{<comma> <identifier> <colon> <expr>}] <r_curly>  
<limit_skip_clause> ::= LIMIT <uint> [ SKIP <uint> ]
```  
If there's more than one return item and at least one aggregation, the result is grouped by the not
aggregated return items. The MAX, MIN, and SUM functions need a numeric type as input and the result
type corresponds to the input type. The COUNT function can take any type as input and the result
type is always BIGINT. MAX(NULL) and MIN(NULL) return NULL, whereas COUNT(NULL) and SUM(NULL) return
0.  
An example with a complex return clause is:  
```OpenCypher
MATCH (a)-[e]->(b)
WHERE e.DIST_KM > 5000.0
RETURN a.NAME AS name, COUNT(b.NAME) AS numLongDistanceConnections
ORDER BY a.NAME ASC
LIMIT 5
SKIP 1
```  
List comprehension is useful for extracting edge attributes of a path.
List comprehension constructs a new list from the given path function, returning a list of edges and
the given expression that can use the given iterator variable.
It's only permitted in the RETURN clause.
The resulting column is a string representation of the list comprehension result in JSON format.
The following expressions are allowed in the list comprehension: attribute accesses, string
concatenations, and constants. The following example shows how to use the list comprehension.  
```OpenCypher
MATCH p = (a)-[*1..2]->(b)
WHERE a.NAME STARTS WITH 'Philadelphia'
RETURN [e IN RELATIONSHIPS(p) | e.TARGET] AS result
```  
The result is:  
|result|
|---|
|[""JFK""]|
|[""JFK"", ""FRA""]|
|[""JFK"", ""AMS""]|
|[""JFK"", ""DXB""]|
|[""JFK"", ""DEL""]|
|[""JFK"", ""PHL""]|  
The object constructor can group several expressions into one expression.
It's only permitted in the RETURN clause.
The resulting column is a string representation of the object in JSON format.
The following example shows how to use the object constructor.  
```OpenCypher
MATCH (a)-[e]->(b)
WHERE a.NAME STARTS WITH 'Dubai'
RETURN { from: e.SOURCE, to: e.TARGET } AS result
```  
The result is:  
|result|
|---|
|{""from"":""DXB"",""to"":""FRA""}|
|{""from"":""DXB"",""to"":""AMS""}|
|{""from"":""DXB"",""to"":""PEK""}|
|{""from"":""DXB"",""to"":""JFK""}|
|{""from"":""DXB"",""to"":""DEL""}|  
The following openCypher query returns the values of the ""NAME"" attribute of all vertices in the
given graph.  
```OpenCypher
MATCH (a)
RETURN a.NAME AS name
ORDER BY a.NAME ASC
```  
The result of this query is a table containing 8 rows:  
|Name|
|---|
|Amsterdam Airport Schiphol|
|Beijing Capital International Airport|
|Dubai International Airport|
|Frankfurt am Main Airport|
|Indira Gandhi International Airport|
|John F Kennedy International Airport|
|Philadelphia International Airport|
|Yaoqiang Airport|  
The following query illustrates the use of the LIMIT clause applied to the result from the previous
example:  
```OpenCypher
MATCH (a)
RETURN a.NAME AS name
ORDER BY a.NAME ASC
LIMIT 5
```  
The result of this query is a table containing 5 rows:  
|Name|
|---|
|Amsterdam Airport Schiphol|
|Beijing Capital International Airport|
|Dubai International Airport|
|Frankfurt am Main Airport|
|Indira Gandhi International Airport|  
The following query illustrates the use of the SKIP clause applied to the result from the previous
example:  
```OpenCypher
MATCH (a)
RETURN a.NAME AS name
ORDER BY a.NAME ASC
LIMIT 5
SKIP 1
```  
The result of this query is the following table:  
|Name|
|---|
|Beijing Capital International Airport|
|Dubai International Airport|
|Frankfurt am Main Airport|
|Indira Gandhi International Airport|
|John F Kennedy International Airport|"
194;109;60;30;40;060-030-040-PriorityQueue.md;PRIORITYQUEUE;Constructors;"PRIORITYQUEUE variables must be initialized with a constructor call which takes the corresponding
graph as only parameter.  
```bnf
<priorityqueue_type> ::=
PRIORITYQUEUE '<' <vertex_or_edge>, <primitive_type> '>'  
<priorityqueue_constructor> ::=
<priorityqueue_type> '(' <graph_variable> ')'
<priorityqueue_definiton> ::= <priorityqueue_type> '=' <priorityqueue_constructor> ';'
```  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
PRIORITYQUEUE<VERTEX, BIGINT> priorityQueueBigIntVertex(:g);
```  
"
195;270;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Map;"
### Constructors  
```graphscript
MAP<BIGINT, DOUBLE> map1(10L);
```  
Constructs an empty map with memory allocated for 10 entries.  
```graphscript
MAP<VERTEX, BIGINT> map2(:g, 100L, 2L);
```  
Constructs a map with 100 entries and default value 2L.  

### Operations  
```graphscript
BIGINT r1 = :map2[:v1];   -- read
map1[3L]  = 3.8;          -- write
BIGINT sz = COUNT(:map1); -- size
```  
"
196;83;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Shortest Path;"```bnf
<sssp_function> ::= SHORTEST_PATH '(' <parent_graph_variable>,
<source_vertex>, <target_vertex> [ , <clos_expr> ] [ , <edge_direction> ] ')'  
<parent_graph_variable> ::= <variable_reference>
<start_vertex> ::= <expr>
<target_vertex> ::= <expr>
<edge_direction> ::= <expr>
```  
Returns a [WEIGHTEDPATH](loio5fd3b8657aec4382b4642780c80940d0) instance containing a shortest path within the given parent graph (first
parameter) from a start vertex (second parameter) to a target vertex (third parameter).
If no path exists from the source vertex to the target vertex, an empty path is returned.
You can use the IS_EMPTY() built-in function to check whether the path is empty.  
By default,the weight metric of the SHORTEST_PATH built-in function is the hop distance, but itâ€™s also
possible to supply a custom weight function as a closure expression (optional fourth parameter).  
The weight function takes an edge, current weight distance, and hop distance as parameters and
returns a value of a numerical type: INTEGER, BIGINT, or DOUBLE. Some of the allowed weight
function declaration examples are: `(EDGE e)`, `(EDGE e, INTEGER w)`,`(EDGE e, BIGINT w, BIGINT h)`.
The last two parameters are optional. When specified, the second parameter will be considered as the
weight distance and the third parameter will be considered as the hop distance. `w` can be an
INTEGER, BIGINT or DOUBLE, and `h` should always be a BIGINT. Using these parameters, bound
conditions can be implemented using IF, ELSE or WHILE clauses. The algorithm passes the weight
distance and hop distance values until the previous edge, to the current edge. The path traversal
can be terminated using END TRAVERSE, though END TRAVERSE ALL isnâ€™t allowed. When END TRAVERSE is
reached, the algorithm ignores the current edge, but doesn't stop evaluating the other
possibilities. The return type of weight function must match the WEIGHTEDPATH weight type.  
Inside of a weight function it is also possible access variables declared outside of it.
This is useful for example to dynamically configure the maximum upper bound for a traversal.
See the example ""Cheapest path that is below $500"" below.  
The edge direction is an optional string parameter to control how the SHORTEST_PATH function treats
the direction of edges in the given input graph. Three values are possible: 'OUTGOING', 'INCOMING',
and 'ANY'. 'OUTGOING' is the default and specifies that the edges' direction is treated exactly as
given in the input graph. 'INCOMING' means the edges' direction is considered reversed during
SHORTEST_PATH search. This is like running SHORTEST_PATH on the inverse input graph. 'ANY' specifies
that SHORTEST_PATH ignores the edge direction and works like itâ€™s running on an undirected graph.  

### Examples  
The following example demonstrates the usage of the SHORTEST_PATH function.
For a more in-depth explanation of the semantics for temporary attributes of vertices and edges in a
path, see the previous subgraph example.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(VERTEX INTEGER vertexAttr = 0, EDGE INTEGER edgeAttr = 42);
VERTEX v_source(:g, 'FRA');
VERTEX v_target(:g, 'JFK');
WEIGHTEDPATH<BIGINT> p = SHORTEST_PATH(:g, :v_source, :v_target);  
SEQUENCE<VERTEX> sv = VERTICES(:p);
SEQUENCE<EDGE> se = EDGES(:p);  
BIGINT lengthOfP = LENGTH(:p);
BIGINT weightOfP = WEIGHT(:p);  
-- Get first edge of path
EDGE e = :se[1L];
-- read edge attribute value --> 42
INTEGER edgeAttrValue = :e.edgeAttr;
```  
The following example demonstrates the use of custom weight functions of various types.
The first path is constructed using a weight function depending on a temporary edge attribute, the
second based on a constant, and the third one based on a non-temporary edge attribute.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"")
WITH TEMPORARY ATTRIBUTES(EDGE INTEGER price = 1);
VERTEX v_source(:g, 'FRA');
VERTEX v_target(:g, 'JFK');
WEIGHTEDPATH<INTEGER> cheapest_path = SHORTEST_PATH(
:g, :v_source, :v_target, (EDGE e)=> INTEGER{ RETURN :e.price; });
WEIGHTEDPATH<BIGINT> least_stopovers = SHORTEST_PATH(
:g, :v_source, :v_target, (EDGE e) => BIGINT{ RETURN 1L; });
WEIGHTEDPATH<DOUBLE> shortest = SHORTEST_PATH(
:g, :v_source, :v_target, (EDGE e) => DOUBLE{ RETURN :e.""DIST_KM""; });
```  
The following example demonstrates the use of weight distance bound inside a weight function. The IF
clause adds the bound conditions and returns the cheapest path that is below $500.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX v_source(:g, 'FRA');
VERTEX v_target(:g, 'JFK');
INTEGER  maximal_price = 500;
WEIGHTEDPATH<INTEGER> cheapest_path = SHORTEST_PATH(
:g, :v_source, :v_target, (EDGE e, INTEGER w)=>
INTEGER{ IF(:w + :e.price < :maximal_price) {return :e.price;}
ELSE {END TRAVERSE;}});
```  
The following example demonstrates the use of both weight distance and hop distance bound inside a
weight function. The IF clause adds the bounds conditions and returns the path that is below $500
and stopovers are less than 2.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX v_source(:g, 'FRA');
VERTEX v_target(:g, 'JFK');
WEIGHTEDPATH<INTEGER> cheapest_and_shortest_path = SHORTEST_PATH(
:g, :v_source, :v_target, (EDGE e, INTEGER w, BIGINT h)=>
INTEGER{ IF(:w + :e.price < 500 AND :h + 1L < 2L) {return :e.price;}
ELSE {END TRAVERSE;}});
```  
The following example demonstrates how to use the edge direction parameter to let the SHORTEST_PATH
function work as if it was operating on a graph with undirected edges.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
VERTEX v_source(:g, 'FRA');
VERTEX v_target(:g, 'JFK');
WEIGHTEDPATH<BIGINT> p = SHORTEST_PATH(:g, :v_source, :v_target, 'ANY');
```  
"
197;108;60;30;40;060-030-040-PriorityQueue.md;PRIORITYQUEUE;;"A priority queue is a collection of elements ordered by their associated priority values  
The elements can be of type VERTEX or EDGE. The priority value can be of type INTEGER, BIGINT or DOUBLE.
Elements are inserted at a position corresponding to their priority. Elements can be fetched from
the front of the queue. The front element is the one with the lowest priority value.  
"
198;166;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;NDIV0;"- NDIV0(INTEGER,INTEGER) => INTEGER
- NDIV0(BIGINT,BIGINT) => BIGINT
- NDIV0(DOUBLE,DOUBLE) => DOUBLE  
"
199;113;60;40;0;060-040-000-Table_Operations.md;Table Operations;Cell Write Access;"Sets the value at a certain index position of a specified table column.
If the index is larger than the row count of the table, then the table is resized accordingly and
padded with NULL values if necessary.  
```graphscript
tab.""IntColumn""[5L] = 123;
```  
"
200;10;40;10;0;040-010-000-Create_Graph_Workspace.md;CREATE GRAPH WORKSPACE Statement (Data Definition);Description;"During the creation of a new graph workspace, the SAP HANA system checks
whether the following conditions are met:
* At one edge table has been specified.
* Each vertex table is unique within the graph workspace.
* All the graph tables and columns exist and have supported data types.
* For graph tables backed by database tables, the above mentioned NOT NULL and UNIQUE constraints
for the key, source and target columns are defined.
* All the vertex and respectively edge attributes with the same name have the same data type.
* If multiple vertex tables are defined, for each edge table the vertex table
referenced by the source and respectively target vertices is specified.
* The explicitly or implicitly defined vertex and respectively edge labels are unique within the graph workspace.
* The creator of the graph workspace has the `CREATE ANY` privilege for the intended graph workspace schema and
the `SELECT` privilege for all the graph tables.
* For `CREATE OR REPLACE`, the user must have additionally the `ALTER` privilege
on the workspace schema or the `ALTER` privilege on the existing workspace.  
A successfully created graph workspace remains valid as long as the above mentioned conditions are fulfilled.  
A valid graph workspace is consistent if every vertex and respectively edge is unique
given its label and not null key attributes and additionally, all the edge source
and target vertices reference existing vertices withing the graph workspace.
Properly defined referential constraints between the tables which define the edge
and vertex tables can guarantee the consistency of the graph workspace.  
<!--! section id=""section_cgw_examples"" -->"
201;152;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;BITCOUNT;"- BITCOUNT(INTEGER,INTEGER) => INTEGER
- BITCOUNT(BIGINT,BIGINT) => BIGINT  
"
202;16;40;20;0;040-020-000-Drop_Graph_Workspace.md;DROP GRAPH WORKSPACE Statement (Data Definition);Example;"Drop the graph workspace ""COMPANY_GRAPH"".  
```sql
DROP GRAPH WORKSPACE COMPANY_GRAPH;
```  
For the complete list of SQL statements used for creating the `""COMPANY_GRAPH""` workspace
please see [Appendix A](loio071d7b7349f04e419507387c271dce8f/section_company_graph_example)."
203;255;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Variables;"Variable names are case-insensitive and unique within a block scope and
all its subscopes.  
```graphscript
INTEGER a = 23;
INTEGER b = 0;
b = :a;
```  
In contrast to write access, read access to a local variable has to be prefixed by a colon.  
"
204;132;60;50;30;060-050-030-Typed_Literals.md;Typed Literals;String Literals;"A character string literal is enclosed in single quotation marks.
The character string literal is optionally prefixed by an N.  
```bnf
<nvarchar_literal>     ::=
<single_quote> {<any_character>-<single_quote>} <single_quote>
| N<single_quote > {<any_character>-<single_quote>} <single_quote>
```  

### Examples  
```graphscript
'Material' -- NVARCHAR
'23' -- NVARCHAR
N'is used in ' -- NVARCHAR
```  
"
205;258;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Conditional Statements;"```graphscript
IF (2 < 3) {
IF (TRUE) {
} ELSE {
}
}
```  
"
206;59;60;20;40;060-020-040-Basic_Edge_Operations.md;Basic Edge Operations;EDGE_EXISTS;"Checks if the given edge, or a edge with the given (composite) edge key exists in a graph or a weighted
path. If multiple edge tables are defined in the graph workspace, it is mandatory to provide a label for the
check by key. The label comes directly after the graph or path variable.  
- EDGE_EXISTS(GRAPH, EDGE) => BOOL
- EDGE_EXISTS(GRAPH, NVARCHAR, scalar_key_type[,scalar_key_type]) => BOOL
- EDGE_EXISTS(WEIGHTEDPATH, EDGE) => BOOL
- EDGE_EXISTS(WEIGHTEDPATH, NVARCHAR, scalar_key_type[,scalar_key_type]) => BOOL  
In the case that only a single edge table is defined, the label can be omitted.  
- EDGE_EXISTS(GRAPH, scalar_key_type[,scalar_key_type]) => BOOL
- EDGE_EXISTS(WEIGHTEDPATH, scalar_key_type[,scalar_key_type]) => BOOL  
"
207;8;40;10;0;040-010-000-Create_Graph_Workspace.md;CREATE GRAPH WORKSPACE Statement (Data Definition);Syntax;"```
CREATE [OR REPLACE] GRAPH WORKSPACE <workspace_name> <graph_tables_definition> [<cache_option>]
```  
<!--! section id=""section_cgw_syntax_elems"" -->"
208;23;50;0;0;050-000-000-Graph_Data_Modification.md;Graph Data Modification;;"Any change to the edge table or the vertex table affects the edges or the vertices of the graph.  
The following SQL statements create two new vertices with vertex keys PEK (Beijing) and TNA
(Jinan), and an edge between them in the ""FLIGHTS"".""GRAPH"" workspace.
For the complete list of statements for creating the example graph in [loio7734f2cfafdb4e8a9d49de5f6829dc32], see [loio071d7b7349f04e419507387c271dce8f](Appendix A).  
```sql
INSERT INTO ""FLIGHTS"".""NODES"" VALUES (
'PEK', 'Airport', 'Beijing Capital International Airport', 'Beijing', 'China',
ST_GEOMFROMTEXT('POINT(116.58499908447266 40.080101013183594)', 4326));
INSERT INTO ""FLIGHTS"".""NODES"" VALUES (
'TNA', 'Airport', 'Yaoqiang Airport', 'Jinan', 'China',
ST_GEOMFROMTEXT('POINT(117.21600341796875 36.857200622558594)', 4326));  
INSERT INTO ""FLIGHTS"".""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('PEK','TNA',361.969);
```  
Vertices can be modified and deleted using SQL UPDATE and DELETE statements.
The following statement modifies the ""COUNTRY"" attribute of all vertices with ""COUNTRY"" 'China'.  
```sql
UPDATE ""FLIGHTS"".""NODES"" SET ""COUNTRY"" = 'PR China'
WHERE ""COUNTRY"" = 'China';
```  
The following statement deletes those edges from the graph workspace ""FLIGHTS"".""GRAPH"" that contain
'FRA' as ""SOURCE"" or ""TARGET"".  
```sql
DELETE FROM ""FLIGHTS"".""EDGES""
WHERE ""SOURCE"" = 'FRA' or ""TARGET"" = 'FRA';
```  
Vertices can be inserted, updated, and deleted in the same way as edges.  
```sql
DELETE FROM ""FLIGHTS"".""NODES""
WHERE ""NODE_KEY"" IN ('FRA', 'AMS');
```  
If the consistency of a graph workspace is not guaranteed by referential constraints, modifications
of the referenced graph tables can lead to
an inconsistent graph workspace. The exact behavior in case of inconsistent graph workspaces is
different for each Graph Engine component. See [loio3d10ffc605524712adbaf5a00495fc37].  
The uniqueness of vertices in the ""FLIGHTS"".""GRAPH"" workspace can be checked with the
following query on the vertex table:  
```sql
SELECT ""NODE_KEY"", COUNT(*)
FROM ""FLIGHTS"".""NODES""
GROUP BY ""NODE_KEY""
HAVING COUNT(*) > 1;
```  
If the result of above query is not empty, then the vertex key column (""NODE_KEY"") contains
duplicates and the graph workspace is inconsistent.  
An analogous query can be used on the edge table to check the uniqueness of edge keys:  
```sql
SELECT ""EDGE_KEY"", COUNT(*)
FROM ""FLIGHTS"".""EDGES""
GROUP BY ""EDGE_KEY""
HAVING COUNT(*) > 1;
```  
The correctness of the source and target vertex references can be checked with the following query:  
```sql
SELECT ""EDGE_KEY"", ""SOURCE"", ""TARGET""
FROM ""FLIGHTS"".""EDGES""
WHERE
""SOURCE"" NOT IN (SELECT ""NODE_KEY"" FROM ""FLIGHTS"".""NODES"")
OR
""TARGET"" NOT IN (SELECT ""NODE_KEY"" FROM ""FLIGHTS"".""NODES"");
```  
If the result of the above query is not empty, then either the source or target of the resulting
edge is not a valid vertex key, leading to an inconsistent graph workspace."
209;78;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Reachable Vertices;"Returns all vertices that are reachable from the given source vertex or vertices.
The result set will include the source vertices.  
- REACHABLE_VERTICES(Graph,Vertex,Nvarchar) => MULTISET<VERTEX>
- REACHABLE_VERTICES(Graph,MultiSet<Vertex>,Nvarchar) => MULTISET<VERTEX>
- REACHABLE_VERTICES(Graph,Sequence<Vertex>,Nvarchar) => MULTISET<VERTEX>  
The first argument is the graph to process. The second argument defines the start vertex/vertices.
The third argument selects the edges which the algorithm follows when it finds connected vertices.
The following values are possible:  
'OUTGOING' traverses the edges as given in the input graph.
'INCOMING' traverses the edges of the input graph in reverse direction.
'ANY' traverses the input graph as if it was undirected.  
"
210;242;70;20;50;070-020-050-Basic_Building_Blocks.md;Basic Building Blocks;Basic Rules;"```bnf
<identifier> ::= <simple_identifier> | <special_identifier>  
<simple_identifier> ::= (<letter> | <underscore>)
{<letter> | <underscore> | <digit>}  
<special_identifier> ::=
<backtick> { (<any_char> - <backtick>) | <backtick><backtick> }<backtick>  
<integer_constant>::
<uint>
| <minus> <uint>  
<bigint_constant> ::= <uint>
| <minus> <uint>  
<double_constant> ::= ( <zero> | <pos_digit> {<digit>}) <dot> <digit> [{<digit}]
| <minus> ( <zero> | <pos_digit> {<digit>}) <dot> <digit> [{<digit}]  
<uint> ::= <zero>
| <positive_digit> [{digit}]  
<varchar_constant> ::= <single_qoute> { ( <any_char> -
( <single_qoute> | <backslash> ) ) | <escaped_char> } <single_quote>  
<escaped_character> ::= <backslash> <single_quote>
| <backslash> <backslash>
```  
<!--! section id=""section_ubg_b2d_wbb"" -->"
211;40;60;20;10;060-020-010-Graph_Primitives.md;Graph Primitives;;"The central domain-specific entities of graph processing are GRAPH, VERTEX, EDGE, and WEIGHTEDPATH.  
- GRAPH  
A GRAPH variable specifies a structured collection of vertices and edges.  
A graph refers to a [graph workspace catalog object](loio72e93671da4b49bda6cf6d7b08346c47) specified by workspace name, an inverse
graph for an already-defined graph, or a subgraph of an already-defined graph.
Alternatively, a graph can be created from [two input tables](loio205a1473ae504ca19d3721ef6c891264/constructors) containing vertices and edges.  
You must initialize a GRAPH variable at the time of declaration.
There's no default initialization for GRAPH variables.  
- VERTEX  
The VERTEX data type specifies a node entity in the graph.  
An existing vertex object can be retrieved from a GRAPH using its key.
Supported keys are composed out of components with a `scalar_key_type` (INTEGER, BIGINT, NVARCHAR) type.
If the graph workspace contains multiple vertex tables, then it is mandatory
to specify the vertex label in addition to the vertex key.
The creation of new vertices within GraphScript isnâ€™t supported.  
You must initialize a VERTEX variable at the time of declaration.
Thereâ€™s no default initialization for VERTEX variables.  
- EDGE  
The EDGE data type specifies a relationship between two vertices in the graph.  
An existing edge object can be retrieved from a GRAPH by using its key.
Like for VERTEX, the keys need to be composed out of components with a `scalar_key_type` type.
If the graph workspace contains multiple edge tables, then also the edge label must be
specified in addition to the edge key.
The creation of new edges isnâ€™t supported.  
You must initialize an EDGE variable at the time of declaration.
Thereâ€™s no default initialization for variables of type EDGE.  
- WEIGHTEDPATH  
The WEIGHTEDPATH data type specifies a path with an associated weight.
A WEIGHTEDPATH consists of a sequence of zero, one, or more vertices connected by edges.  
You create a WEIGHTEDPATH by calling one of the built-in shortest path functions.
GraphScript supports several operations on WEIGHTEDPATH variables, such as extracting its vertices
and edges and calculating the length and the weight of a path.
You must initialize a WEIGHTEDPATH variable at the time of declaration.
Thereâ€™s no default initialization for WEIGHTEDPATH variables.
The WEIGHTEDPATH type must be specialized with a weight type.
The following weight types are currently supported: INT, DOUBLE, and BIGINT.
These types lead to the following WEIGHTEDPATH types: `WEIGHTEDPATH<INT>`, `WEIGHTEDPATH<DOUBLE>`,
and `WEIGHTEDPATH<BIGINT>`."
212;9;40;10;0;040-010-000-Create_Graph_Workspace.md;CREATE GRAPH WORKSPACE Statement (Data Definition);Syntax Elements;"
### OR REPLACE  
The behavior of CREATE OR REPLACE depends on the existence of a previously defined
graph workspace. If the graph workspace does not exist, then a new graph workspace
is created and the statement behaves like CREATE GRAPH WORKSPACE.
If the workspace already exists, then the workspace is altered according
to the new definition - in this case, the owner of the workspace as well as all
the privileges associated with the graph workspace are preserved.  

### <workspace_name>  
Specifies the name of the graph workspace.  
```
<workspace_name> ::= [<schema_name>.]<identifier>
```  

### <graph_tables_definition>  
Specifies the vertex and edge tables.
Multiple vertex and edge tables can be specified in any order.
A valid graph workspace must contain at least one edge table.
Currently, each vertex table must be unique within the graph workspace.  
For graph workspaces without vertex tables, see the subsection ""Workspaces without vertex table""
below.  
```
<graph_tables_definition> ::= { <vertex_table_definition> | <edge_table_definition> } [...]
```  

### <vertex_table_definition>  
Specifies a vertex table.  
```
<vertex_table_definition> = VERTEX TABLE <table_name> <vertex_key_label_specifications>
```  

### <vertex_key_label_specifications>  
Specifies the key and label of the vertex table.
Both single column and multi-column keys are supported.
The specification of the key is mandatory while the label specification is optional.
For each vertex table, exactly one key must be specified and at most one label
can be explicitly defined.
The two specifications can be made in any order.  
```
<vertex_key_label_specifications> = { <key_columns_specification> | <label_specification> } [...]
```  

### <edge_table_definition>  
Specifies an edge table.  
```
<edge_table_definition> = EDGE TABLE <table_name> <edge_key_source_target_label_specifications>
```  

### <edge_key_source_target_label_specifications>  
Specifies the mandatory edge key, source vertex key and target vertex key of the
edge table. Both single column and multi-column keys are supported.
Additionally, an optional label can be specified.
For each edge table, exactly one edge key, one source vertex key and one target
vertex key must be specified and at most one label can be explicitly defined.
The specifications can be made in any order.  
```
<edge_key_source_target_label_specifications> =
{ <key_columns_specification> | <source_columns_specification> | <target_columns_specification> | <label_specification> } [...]
```  

### <table_name>  
Specifies the name of a graph table (i.e., vertex or edge table).
A graph table can be either a table, a view or a synonym.  
```
<table_name> ::= [<schema_name>.]<identifier>
```  
The graph workspace and the graph tables can reside in different schemas.
If any of the schemas are omitted, then the default schema is assumed.  

### <key_columns_specification>  
Specifies the columns which uniquely identify a vertex in a vertex table or an edge in an edge table.
These columns are also denoted as vertex and edge key attributes, respectively.  
```
<key_columns_specification> ::= KEY [COLUMN] <column_name_list>
<column_name_list> ::= <column_name> [ { , <column_name> } [...] ]
<column_name> ::= <identifier>
```  
The vertex and edge key columns can have one of the following SQL types: TINYINT, SMALLINT, INTEGER,
BIGINT, NVARCHAR, or VARBINARY. For performance reasons, integer types are recommended.
Each key column of a graph table backed by a database table must have the NOT NULL constraint and
additionally, the key columns must also have the UNIQUE constraint.  

### <label_specification>  
Specifies the label of the corresponding graph table. The label specification is optional
and if missing, then the label defaults to the corresponding vertex or edge table name.  
```
<label_specification> ::= LABEL <string_literal>
```  
The label can be used later in both [GraphScript](loio47b72452f48f4ca490fbffcb5ca31f92)
and [openCypher](loio4c3ee700e7a8458baed3f1141d9380f3).  

### <source_columns_specification>  
Specifies the columns which uniquely identify the source vertices of the edges in the corresponding edge table.  
```
<source_columns_specification> ::= SOURCE [COLUMN] <column_name_list> [<vertex_table_reference>]
```  

### <target_columns_specification>  
Specifies the columns which uniquely identify the target vertices of the edges in the corresponding edge table.  
```
<target_columns_specification> ::= TARGET [COLUMN] <column_name_list> [<vertex_table_reference>]
```  
If the edge table is backed by a database table, then the source and target columns must have the NOT NULL constraint.  

### <vertex_table_reference>  
Specifies the referenced vertex table. By default, the key columns of the specified vertex table are referenced.  
```
<vertex_table_reference> ::= REFERENCES <table_name>
```  

### <cache_option>  
Specifies the caching strategy. For each graph workspace used in
[GraphScript](loio47b72452f48f4ca490fbffcb5ca31f92)
a secondary index structure is built in order to speed-up GraphScript program execution.
Depending on the selected caching option and underlying data store, this index can be kept in-memory
and re-used in subsequent GraphScript program invocations.  
```
<cache_option> ::= WITH DYNAMIC CACHE | NO CACHE | WITH STATIC CACHE RETENTION <unsigned_integer>
```  
For the default option WITH DYNAMIC CACHE, the cache is managed automatically. The graph always
reflects the current transactional view of the underlying source objects. If the graph is completely
based on column store sources, the system tries to avoid full index updates and rather handles
source updates incrementally on access, so in most cases dynamic caching is preferable.  
NO CACHE disables the caching for this specific graph workspace, which may be appropriate if a graph
is accessed only once or memory resources are scarce.  
If the WITH STATIC CACHE RETENTION option is selected, it is mandatory to specify
the time in minutes until the cache entry is invalidated. Then after initial access the system is
allowed to skip updates of internal graph data structures irrespective of changes of the underlying
data. If a graph is accessed after its retention period has expired, then its internal index
structures are updated according to all intermediate source data updates. This update may initiate a
renewed stable retention period.  

### Workspaces without vertex table  
It is possible to create a graph workspace without a vertex table. This is possible if exactly one
edge table is provided.  
In case the vertex table is omitted, the system will implicitely create vertex data based on the
contents of the edge table. The vertex data will be the union of entities referenced in the SOURCE
fields and entities referenced in the TARGET fields of the edge table.  
The implicit vertices use the key attribute names KEY_1, ..., KEY_N. The respective data types
correspond to the datatypes of the source/target fields in the edge table. The vertices do not have
any other additional attributes.  
<!--! section id=""section_cgw_description"" -->"
213;28;60;5;0;060-005-000-Integration_into_Stored_Procs.md;Integration into the SAP HANA Environment;GraphScript Table User-Defined Functions;"Similar to SQLScript, GraphScript supports table user-defined functions (TUDF).
A GraphScript TUDF can only be called within the FROM-clause of an SQL statement
at the same parameter positions as table names.  
<!--! subsection id=""GraphScript_Table_User_Defined_Function_Syntax""-->
### Syntax  
Creates a GraphScript table function.  
```bnf
CREATE [OR REPLACE] FUNCTION <function_name> [(<function_parameters>)]
<return_clause>
LANGUAGE GRAPH [<sql_security_mode>] [<default_schema_specification>]
[READS SQL DATA] AS
BEGIN
<GraphScript_function_body>
END
```
<!--! subsection id=""GraphScript_Table_User_Defined_Function_Syntax_Elements""-->
### Syntax Elements  
The optional syntax elements <sql_security_mode> and <default_schema_specification>
are the same as for the GraphScript procedures defined above.  
#### <function_name>  
Specifies the name of the function with an optional schema name.  
```bnf
<function_name> ::= [<schema_name>.]<identifier>
```  
#### <function_parameters>  
Specifies the parameters of the table function.  
```bnf
<function_parameters> ::= <in_parameter> [ { , <in_parameter> } [...] ]  
<in_parameter> ::= [IN] <parameter_name> <data_or_table_type>
```  
Functions have only input parameters, therefore the specifier IN is optional.
Functions support the same parameter data types as procedures.  
#### <return_clause>  
Defines the type of the return table.  
```bnf
<return_clause> ::= RETURNS { <table_type> | <table_type_definition> }
```  
<!--! subsection id=""GraphScript_Table_User_Defined_Function_Description""-->
### Description  
GraphScript table functions support the same feature set as GraphScript procedures.
Additionally, a table function must return a table of the type defined in the return clause.
To this end, GraphScript provides the [return table statement](loio0a2875fccc6b4201921e23683d9c3af3/return_table_statement).  
Table functions are always read only. Therefore, the READS SQL DATA specification is optional.  
Currently, GraphScript table functions do not provide support for debugging.  
The [example](loio95320185c30b4565853f22062a42c219/section_tudf_example)
illustrates the usage of a GraphScript table user-defined function
which determines all the employees who work on projects that produce products
bought by a specific customer based on the Company graph described in
[Appendix A](loio071d7b7349f04e419507387c271dce8f/section_company_graph_example)."
214;275;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Traversal Hooks;"```graphscript
TRAVERSE BFS :g FROM VERTEX(:g, 1)
ON VISIT VERTEX (VERTEX v) {
INTEGER attrVal = :v.attr;
};
```  
Breadth-first traversal with vertex hook.  
```graphscript
TRAVERSE BFS :g FROM VERTEX(:g, 1)
ON VISIT VERTEX (VERTEX v, BIGINT lvl) {
v.attr = :lvl;
};
```  
Breadth-first traversal with vertex hook and traversal depth.  
```graphscript
TRAVERSE DFS :g FROM VERTEX(:g, 1)
ON VISIT EDGE (EDGE e) {
INTEGER attrVal = :e.attr;
};
```  
Depth-first traversal with edge hook.  
```graphscript
TRAVERSE BFS :g FROM VERTEX(:g, 1)
ON VISIT EDGE (EDGE e, BIGINT lvl) {
e.attr = :lvl;
};
```  
Breadth-first traversal with edge hook and traversal depth.  
```graphscript
TRAVERSE BFS :g FROM VERTEX(:g, 1)
ON VISIT VERTEX (VERTEX v, BIGINT lvl) {
v.attr = :lvl;
}
ON VISIT EDGE (EDGE e) {
INTEGER attrVal = :e.attr;
};
```  
Breadth-first traversal with vertex and edge hooks and traversal depth.  
```graphscript
TRAVERSE DFS :g FROM VERTEX(:g, 1)
ON VISIT VERTEX (VERTEX v) {
IF (:v.attrVal == 42) {
END TRAVERSE ALL;
}
};
```  
Depth-first traversal with END TRAVERSE ALL statement in vertex hook.  
```graphscript
TRAVERSE BFS :g FROM VERTEX(:g, 1)
ON VISIT EDGE (EDGE e) {
IF (:e.attrVal != 'open') {
END TRAVERSE;
}
};
```  
Breadth-first traversal with END TRAVERSE statement in edge hook."
215;161;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;FLOOR;"- FLOOR(INTEGER) => INTEGER
- FLOOR(BIGINT) => BIGINT
- FLOOR(DOUBLE) => DOUBLE  
"
216;61;60;20;40;060-020-040-Basic_Edge_Operations.md;Basic Edge Operations;SOURCE;"Returns the source vertex of an edge.  
- SOURCE(EDGE) => VERTEX  
"
217;190;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;LAST_DAY;"Returns the DATE or TIMESTAMP value of the last day of the month of the specified DATE or TIMESTAMP value.  
- LAST_DAY(DATE) => DATE
- LAST_DAY(TIMESTAMP) => TIMESTAMP  
"
218;24;60;0;0;060-000-000-GraphScript_Language.md;GraphScript Language;;"GraphScript is an imperative programming language that provides application developers with a
high-level interface for accessing the graph data defined by a graph workspace.  
The GraphScript language eases the development of application-specific
graph algorithms and integrates them into SQL-based data processing.
Furthermore, GraphScript provides optimized built-in algorithms to solve common graph-related
problems, such as finding the shortest path from one vertex to another.
These algorithms are available as built-in functions that can be reused
in any GraphScript program to simplify the development of efficient
solutions for customer-specific, graph-related problems.  
In case of inconsistent graph workspaces, a GraphScript program will terminate with an error."
219;13;40;20;0;040-020-000-Drop_Graph_Workspace.md;DROP GRAPH WORKSPACE Statement (Data Definition);Syntax;"```
DROP GRAPH WORKSPACE <workspace_name> [CASCADE]
```  
<!--! section id=""section_dgw_syntax_elems"" -->"
220;183;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;NANOSECOND;"Extracts the nanosecond component from a TIMESTAMP value.  
- NANOSECOND(TIMESTAMP) => INTEGER  
"
221;217;70;10;0;070-010-000-OPENCYPHER_TABLE_SQL_Function.md;OPENCYPHER_TABLE SQL Function;Syntax Elements;"
### <graph_workspace_spec>  
Specifies the graph workspace used with the openCypher query.  
```
<graph_workspace_spec> ::= GRAPH WORKSPACE <graph_workspace>
```  
`<graph_workspace>` can be any graph workspace present in the system, identified by an optional
schema name and a workspace name.  

### <opencypher_query_spec>  
Specifies a query in the openCypher language.  
```
<opencypher_query_spec> ::= QUERY <opencypher_query_string>
```  
`<opencypher_query_string>` is a string or nstring literal that corresponds to a pattern matching
query in the openCypher language.
Although `<opencypher_query_string>` appears to be a normal SQL string, it's actually part of the
query syntax and can't be replaced with a string expression like most SQL strings.
To parameterize it, dynamic SQL has to be used.  

### <parameters_spec>  
Specifies the parameters used with the openCypher query.  
```
<parameters_spec> ::= PARAMETERS <l_paren> <parameters> <r_paren>  
<parameters> ::= <parameter>
| <parameters> <comma> <parameter>  
<parameter> ::= <single_quote> <parameter_name> <single_quote> <equals> <questionmark>
```  
The parameters within the query specification have to be preceded by a dollar sign.  
<!--! note -->
#### Note  
Since a single-quoted SQL string is used for the openCypher query, single quotes (') inside the
openCypher query have to be escaped by using two single quotes ('').  
<!--! end-note -->  
<!--! section id=""section_tz2_z1n_xgb"" -->"
222;111;60;40;0;060-040-000-Table_Operations.md;Table Operations;;"Tables are the central means for exchanging larger chunks of data between GraphScript procedures and
their outside database environment. Tables can't be instantiated within GraphScript procedures,
so they're always passed as input or output parameters. All column types must be compatible with
GraphScript types. If an input table contains an unsupported column type, it cannot be accessed in
the GraphScript procedure.
"
223;212;60;70;0;060-070-000-Complex_GraphScript_Examples.md;Complex GraphScript Examples;GraphScript Anonymous Block Example;"The following example uses the Company graph described in
[loio071d7b7349f04e419507387c271dce8f](Appendix A) to determine all the employees
who work on projects that produce products bought by a specific customer.  
```sql
DO (IN CUSTOMER_ID BIGINT => 1, -- The key of the customer in the ""CUSTOMERS"" table
OUT EMPLOYEES TABLE (FIRST_NAME NVARCHAR(100), LAST_NAME NVARCHAR(100)) => ?)
LANGUAGE GRAPH
BEGIN
-- Create an instance of the graph, referring to the graph workspace object
GRAPH g = GRAPH(""COMPANY_SCHEMA"", ""COMPANY_GRAPH"");
-- Create a vertex which corresponds to the customer with the provided CUSTOMER_ID.
-- For the vertex table ""CUSTOMERS"" no label has been explicitly defined.
-- In this case, the label defaults to the name of the table.
VERTEX v_customer = VERTEX(:g, 'CUSTOMERS', :CUSTOMER_ID);
-- The maximum hop distance between any two vertices in the given ""COMPANY_GRAPH"" is three.
-- Identify all the vertices reachable from the customer vertex regardless of the edge direction.
MULTISET<VERTEX> m_neighbors = NEIGHBORS(:g, :v_customer, 1, 3, 'ANY');
-- Filter the employees out of the reachable vertices.
-- The employees are identified by the label 'Employee'.
MULTISET<VERTEX> m_employees = v in :m_neighbors where LABEL(:v) == 'Employee';
-- Project the FIRST_NAME and the LAST_NAME of all found employees.
EMPLOYEES = SELECT :v.FIRST_NAME, :v.LAST_NAME FOREACH v IN :m_employees;
END;
```  
<!--! section id=""section_tudf_example"" -->"
224;214;70;0;0;070-000-000-openCypher_Pattern_Matching.md;openCypher Pattern Matching;;"openCypher is a declarative graph query language for graph pattern matching developed by the
openCypher Implementers Group. (Cypher is a registered trademark of Neo4j, Inc.)  
SAP HANA Graph allows you to use openCypher directly in SQL. This topic describes the SQL
interface and the currently supported subset of the openCypher query language."
225;7;40;10;0;040-010-000-Create_Graph_Workspace.md;CREATE GRAPH WORKSPACE Statement (Data Definition);;"Creates a graph workspace.  
<!--! section id=""section_cgw_syntax"" -->"
226;184;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;SECOND;"Extracts the second component from a TIMESTAMP value.  
- SECOND(TIMESTAMP) => INTEGER  
"
227;246;90;20;0;090-020-000-Appendix_A_-_Open_Flights_Graph_Example.md;Appendix A - Open Flights and Company Graph Examples;Open Flights Graph Example;"Use the following SQL statements to create the Open Flights graph example.  

### Create Vertex and Edge Tables (Open Flights)  
```sql
CREATE SCHEMA ""FLIGHTS"";
SET SCHEMA ""FLIGHTS"";  
CREATE TABLE ""NODES"" (
""NODE_KEY"" NVARCHAR(100) PRIMARY KEY,
""TYPE""     NVARCHAR(100),
""NAME""     NVARCHAR(100),
""CITY""     NVARCHAR(100),
""COUNTRY""  NVARCHAR(100),
""LOCATION"" ST_GEOMETRY(4326)
);  
CREATE TABLE ""EDGES"" (
""EDGE_KEY"" BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
""SOURCE"" NVARCHAR(100) NOT NULL REFERENCES ""NODES"" (""NODE_KEY"")
ON UPDATE CASCADE ON DELETE CASCADE,
""TARGET"" NVARCHAR(100) NOT NULL REFERENCES ""NODES"" (""NODE_KEY"")
ON UPDATE CASCADE ON DELETE CASCADE,
""DIST_KM"" DOUBLE
);
```  

### Create Graph Workspace (Open Flights)  
```sql
CREATE GRAPH WORKSPACE GRAPH
EDGE TABLE EDGES
KEY EDGE_KEY
SOURCE SOURCE
TARGET TARGET
VERTEX TABLE NODES
KEY NODE_KEY;
```  

### Insert Rows into Vertex Table (Open Flights)  
```sql
INSERT INTO ""NODES"" VALUES (
'FRA', 'Airport', 'Frankfurt am Main Airport', 'Frankfurt am Main', 'Germany',
ST_GEOMFROMTEXT('POINT(8.570556 50.033333)', 4326));
INSERT INTO ""NODES"" VALUES (
'JFK', 'Airport', 'John F Kennedy International Airport', 'New York', 'United States',
ST_GEOMFROMTEXT('POINT(-73.77890015 -73.77890015)', 4326));
INSERT INTO ""NODES"" VALUES (
'DXB', 'Airport', 'Dubai International Airport', 'Dubai', 'United Arab Emirates',
ST_GEOMFROMTEXT('POINT(55.3643989563 25.2527999878)', 4326));
INSERT INTO ""NODES"" VALUES (
'AMS', 'Airport', 'Amsterdam Airport Schiphol', 'Amsterdam', 'Netherlands',
ST_GEOMFROMTEXT('POINT(4.76389 52.308601)', 4326));
INSERT INTO ""NODES"" VALUES (
'PEK', 'Airport', 'Beijing Capital International Airport', 'Beijing', 'China',
ST_GEOMFROMTEXT('POINT(116.58499908447266 40.080101013183594)', 4326));
INSERT INTO ""NODES"" VALUES (
'DEL', 'Airport', 'Indira Gandhi International Airport', 'Delhi', 'India',
ST_GEOMFROMTEXT('POINT(77.103104 28.5665)', 4326));
INSERT INTO ""NODES"" VALUES (
'PHL', 'Airport', 'Philadelphia International Airport', 'Philadelphia', 'United States',
ST_GEOMFROMTEXT('POINT(-75.24109649658203 -75.24109649658203)', 4326));
INSERT INTO ""NODES"" VALUES (
'TNA', 'Airport', 'Yaoqiang Airport', 'Jinan', 'China',
ST_GEOMFROMTEXT('POINT(117.21600341796875 36.857200622558594)', 4326));
```  

### Insert Rows into Edge Table (Open Flights)  
```sql
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('FRA','PEK',7808.278);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DEL','FRA',6131.81);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('JFK','FRA',6206.163);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('PEK','FRA',7808.278);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('AMS','FRA',367.268);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DXB','FRA',4848.058);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('FRA','JFK',6206.163);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('JFK','AMS',5863.339);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('PEK','AMS',7848.339);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DXB','AMS',5174.013);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DEL','AMS',6375.078);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('FRA','AMS',367.268);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('FRA','DXB',4848.058);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('FRA','DEL',6131.81);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DEL','PEK',3815.291);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DXB','PEK',5855.097);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('AMS','PEK',7848.339);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DEL','DXB',2187.214);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('PEK','DXB',5855.097);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('AMS','DXB',5174.013);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('JFK','DXB',11021.831);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DEL','JFK',11776.798);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('AMS','JFK',5863.339);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DXB','JFK',11021.831);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('AMS','DEL',6375.078);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('PEK','DEL',3815.291);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('DXB','DEL',2187.214);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('JFK','DEL',11776.798);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('PHL','JFK',150.81);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('JFK','PHL',150.81);
INSERT INTO ""EDGES"" (""SOURCE"", ""TARGET"", ""DIST_KM"") VALUES ('PEK','TNA',361.969);
```  
<!--! section id=""section_company_graph_example"" -->"
228;2;20;0;0;020-000-000-Introduction.md;Introduction;;"SAP HANA Graph is an integral part of the SAP HANA core functionality.
It expands the SAP HANA platform with native support for graph processing and enables the execution
of typical graph operations on the data stored in an SAP HANA system."
229;159;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;COT;"- COT(DOUBLE) => DOUBLE  
"
230;114;60;40;0;060-040-000-Table_Operations.md;Table Operations;Row Count;"The row count of a table can be determined using the COUNT function expression.  
```graphscript
BIGINT numRows = COUNT(:tab);
```  

### Examples  
```graphscript
CREATE TYPE tt AS TABLE(NAME NVARCHAR, ATTR INTEGER);  
CREATE PROCEDURE myTableProc (IN i_tab tt, OUT o_i INTEGER, OUT o_numRows BIGINT)
LANGUAGE GRAPH READS SQL DATA AS
BEGIN
o_i = :i_tab.ATTR[1L];
i_tab.""NAME""[3L] = ""John"";
o_numRows = COUNT(:i_tab);
END;
```  
"
231;202;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;YEARS_BETWEEN;"Computes the number of years between two specified DATE or TIMESTAMP values.  
- YEARS_BETWEEN(DATE, DATE) => INTEGER
- YEARS_BETWEEN(TIMESTAMP, TIMESTAMP) => INTEGER"
232;14;40;20;0;040-020-000-Drop_Graph_Workspace.md;DROP GRAPH WORKSPACE Statement (Data Definition);Syntax Elements;"
### <workspace_name>  
Specifies the name of the graph workspace.  
```
<workspace_name> ::= [<schema_name>.]<identifier>
```  
### CASCADE  
Drops the graph workspace and dependent objects (e.g., GraphScript procedures and
table functions which reference the graph workspace).  
<!--! section id=""section_dgw_description"" -->"
233;49;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;LABEL;"Returns the label of a given vertex. If no label was specified for a vertex table in the graph
workspace, the name of the table is returned.  
- LABEL(Vertex) => NVARCHAR  
"
234;274;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Datetime Functions;"|Signature|Return|Description|
|---|---|---|
|`YEAR(TIMESTAMP)`|`INTEGER`|extract year|
|`MONTH(TIMESTAMP)`|`INTEGER`|extract month|
|`DAYOFMONTH(TIMESTAMP)`|`INTEGER`|extract day|
|`HOUR(TIMESTAMP)`|`INTEGER`|extract hour|
|`MINUTE(TIMESTAMP)`|`INTEGER`|extract minute|
|`SECOND(TIMESTAMP)`|`INTEGER`|extract second|
|`NANOSECOND(TIMESTAMP)`|`INTEGER`|extract nanosecond|
|`CURRENT_TIMESTAMP()`|`TIMESTAMP`|extract current timestamp|
|`CURRENT_UTCTIMESTAMP()`|`TIMESTAMP`|extract UTC timestamp|
|`LAST_DAY(TIMESTAMP)`|`TIMESTAMP`|extract last day of the month|
|`ADD_NANO100(TIMESTAMP, BIGINT)`|`TIMESTAMP`|add or subtract specified 0.1 microsecond units|
|`ADD_SECONDS(TIMESTAMP, INTEGER)`|`TIMESTAMP`|add or subtract seconds|
|`ADD_MINUTES(TIMESTAMP, INTEGER)`|`TIMESTAMP`|add or subtract minutes|
|`ADD_HOURS(TIMESTAMP, INTEGER)`|`TIMESTAMP`|add or subtract hours|
|`ADD_DAYS(TIMESTAMP, INTEGER)`|`TIMESTAMP`|add or subtract days|
|`ADD_MONTHS(TIMESTAMP, INTEGER)`|`TIMESTAMP`|add or subtract months|
|`ADD_YEARS(TIMESTAMP, INTEGER)`|`TIMESTAMP`|add or subtract years|
|`NANO100_BETWEEN(TIMESTAMP, TIMESTAMP)`|`BIGINT`|difference in 0.1 microsecond units|
|`SECONDS_BETWEEN(TIMESTAMP, TIMESTAMP)`|`BIGINT`|difference in seconds|
|`DAYS_BETWEEN(TIMESTAMP, TIMESTAMP)`|`INTEGER`|difference in days|
|`MONTHS_BETWEEN(TIMESTAMP, TIMESTAMP)`|`INTEGER`|difference in months|
|`YEARS_BETWEEN(TIMESTAMP, TIMESTAMP)`|`INTEGER`|difference in years|  
"
235;32;60;10;0;060-010-000-Language_Fundamentals.md;Language Fundamentals;Local Variables;"GraphScript supports local variables that split large and complex statements into smaller ones,
improving the script's overall readability. After initial assignment or declaration (see
[loio205a1473ae504ca19d3721ef6c891264/assignment_statements_060-070-000] in
[loio205a1473ae504ca19d3721ef6c891264] ), the type of a variable can no longer be modified.
A local variable expression can be used anywhere that an expression is supported, as long as the
corresponding expression types match.
The names of variables are case insensitive.
Variable references that are used for read access must be preceded by a colon (:), while references
for write access have no leading colon.  
```bnf
<variable> ::= <letter> { <letter> | <digit> | <underscore> }
<variable_reference> ::= <colon> <letter> { <letter> | <digit> | <underscore> }
<local_var_expr> ::= <variable_reference>
```  

### Examples  
```graphscript
aVariable
aSecondVariable12
:aVariable
```  
<!--! section id=""section_yhl_kgc_1hb"" -->"
236;201;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;MONTHS_BETWEEN;"Computes the number of months between two specified DATE or TIMESTAMP values.  
- MONTHS_BETWEEN(DATE, DATE) => INTEGER
- MONTHS_BETWEEN(TIMESTAMP, TIMESTAMP) => INTEGER  
"
237;53;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;EDGES;"Returns all the incoming and outgoing edges of a vertex.  
- EDGES(VERTEX) => MULTISET  
"
238;251;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Scalar Data Types;"
### Integer (32-bit, signed, nullable)  
```graphscript
INTEGER i = 23;
i = INTEGER(45L);        -- cast BigInt to Integer
i = INTEGER(23.5);       -- cast Double to Integer
```  

### BigInt (64-bit, signed, nullable)  
```graphscript
BIGINT b = 23L;
b = BIGINT(45);       -- cast Integer to BigInt
b = BIGINT(5.2, 6L);  -- cast Double to Bigint. If the cast fails or the first argument is NULL,
then the second argument is returned. Hence, b = 5L.
```  

### Double (64-bit, signed, nullable)  
```graphscript
DOUBLE d = 23.5;
d = DOUBLE(12L);      -- cast BigInt to Double
INTEGER i = NULL;
d = DOUBLE(:i, 3.5);  -- cast Integer to Double. If the cast fails or the first argument is NULL,
then the second argument is returned. Hence, d = 3.5.
```  

### String Type  
```graphscript
NVARCHAR n = 'Test';
n = NVARCHAR(3, 'abc'); -- cast Integer to Nvarchar. If the first argument is NULL, then the second
argument is returned. Hence, n = '3'.
```  
All strings are variable-length and support unicode characters.  

### Boolean Type  
```graphscript
BOOLEAN b = TRUE;
```  
Defines a boolean variable with initial value `TRUE`. The default value is `FALSE`.  

### Timestamp  
```graphscript
TIMESTAMP t = TIMESTAMP(
'2010-03-17 12:34:57.1234567');
```  
Defines a timestamp variable from a string.
The format is `yyyy-mm-dd HH:MM:SS.NNNNNNN`.  
"
239;105;60;30;30;060-030-030-Map.md;MAP;Constructors;"MAP variables must be initialized with a constructor call which takes the expected amount of entries
as parameter of type BIGINT. Optionally, a default value can be specified as the last parameter.
If the key type is VERTEX or EDGE, the corresponding graph variable must be passed as the first
parameter.  
```bnf
<map_type> ::=
MAP '<' <vertex_or_edge>, <primitive_type> '>'
| MAP '<' <primitive_type>, <primitive_type> '>'  
<map_constructor> ::=
<map_type> '(' <expected_size> [, <default_value>] ')'
| <map_type> '(' <graph_variable>, <expected_size> [, <default_value>] ')'
<map_definiton> ::= <map_type> '=' <map_constructor> ';'
```  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
BIGINT expected_size = 100L;
MAP<VERTEX, NVARCHAR> mapVertex(:g, :expected_size, 'default value');
MAP<BIGINT, DOUBLE> mapInt(10L);
```  
"
240;141;60;50;40;060-050-040-Type_Casts.md;Type Casts;TIMESTAMP;"Casts a NVARCHAR value to a TIMESTAMP value.  
- TIMESTAMP(TIMESTAMP) => TIMESTAMP
- TIMESTAMP(NVARCHAR) => TIMESTAMP  
It is also possible to provide a second argument having type TIMESTAMP.  
- TIMESTAMP(TIMESTAMP,TIMESTAMP) => Returns the first argument as long it is not NULL, else it returns the second
argument.
- TIMESTAMP(NVARCHAR,TIMESTAMP) => Type casts NVARCHAR to TIMESTAMP. If it fails or is NULL, it returns the second argument.  
```graphscript
TIMESTAMP var1 = TIMESTAMP('1972-04-01 01:01:01.0000001');
TIMESTAMP var2 = TIMESTAMP('HANA', :var1); -- var2 is '1972-04-01 01:01:01.0000001'
```  
"
241;229;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;;"SAP HANA Graph supports a subset of openCypher built-in functions and offers a set of SAP HANA-specific built-in functions.  
```bnf
<builtin_function> ::= <opencypher_builtin_function> | <hana_builtin_function>
```  
openCypher built-in functions are case-insensitive.
SAP HANA-specific built-in functions are defined in the SYS namespace and are case-sensitive.  
```bnf
<hana_builtin_function> ::= SYS '.' <text_contains_function>  
<opencypher_builtin_function> ::= <all_function> | <relationships_function>
```  
<!--! section id=""_"" -->"
242;76;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;Edges Between;"Returns all edges between a start set or vertex and a target set or vertex in a graph.  
- EDGES(GRAPH, MULTISET, MULTISET) => MULTISET
- EDGES(GRAPH, MULTISET, VERTEX) => MULTISET
- EDGES(GRAPH, VERTEX, MULTISET) => MULTISET
- EDGES(GRAPH, VERTEX, VERTEX) => MULTISET
- EDGES(GRAPH, SEQUENCE, SEQUENCE) => MULTISET
- EDGES(GRAPH, SEQUENCE, MULTISET) => MULTISET
- EDGES(GRAPH, MULTISET, SEQUENCE) => MULTISET
- EDGES(GRAPH, SEQUENCE, VERTEX) => MULTISET
- EDGES(GRAPH, VERTEX, SEQUENCE) => MULTISET  
"
243;223;70;20;10;070-020-010-Match_Clause.md;MATCH Clause;Non-Topological Constraints;"non-topological constraints is a Boolean expression that is evaluated on each matched subgraph.
This expression can contain many predicates that are combined by the logical connectives AND, OR,
and NOT.  
```bnf
<non_topology_constraints> ::= <condition>  
<condition> ::= <condition> OR <condition>
| <condition> AND <condition>
| NOT <condition>
| <builtin_function>
| <l_paren> <condition> <r_paren>
| <predicate>
```  
Predicates include comparisons (=, <>, >, <, >=, <=), IS NULL, and other Boolean built-in functions.  
```bnf
<predicate> ::= <comparison_predicate>
| <attribute access> IS NULL
| <attribute access> CONTAINS <nvarchar constant>
| <attribute access> STARTS WITH <nvarchar constant>
| <attribute access> ENDS WITH <nvarchar constant>  
<comparison_predicate> ::=
<expression> <equals> <expression>
| <expression> <unequal> <expression>
| <expression> <greater> <expression>
| <expression> <smaller> <expression>
| <expression> <greater_equal> <expression>
| <expression> <smaller_equal> <expression>  
<expression> ::=
<attribute access>
| <constant>
| <parameter>
| <expression> <operator> <expression>
<attribute access> ::= <variable_name> <dot> <attribute_name>
<variable_name> ::= <identifier>
<attribute_name> ::= <identifier>
<label_name> ::= <identifier>
<constant> ::= <integer_constant>
| <bigint_constant>
| <double_constant>
| <varchar_constant>
<parameter> ::= <dollar_sign> <identifier>
<operator> ::= <plus>
| <minus>
| <asterix>
| <slash>
| <modulo>
| <circumflex>
```
For numerical expressions the operators correspond to the common arithmetic functions.
For string values the plus operator corresponds to the string concatenation.
The following query illustrates string concatenation and the use of the logical connective NOT.
Note that NOT has higher precedence than AND and OR. Therefore, NOT is evaluated first.  
```OpenCypher
MATCH (a)-[e]->(b)
WHERE a.NAME = ''John F Kennedy'' + '' International Airport''
AND (e.EDGE_KEY < 4 OR NOT b.NAME <> ''Philadelphia International Airport'')
RETURN b.NAME AS Name
ORDER BY b.NAME
```  
The following query illustrates the use of the logical connective OR.
Note that OR has lower precedence than AND.  
```OpenCypher
MATCH (a)-[e]->(b)
WHERE a.NAME = 'John F Kennedy International Airport'
AND e.EDGE_KEY > 4 OR b.NAME = 'Philadelphia International Airport'
RETURN b.NAME AS Name
ORDER BY b.NAME
```  
The following query illustrates the use of parentheses to evaluate the OR connective before the AND
connective.  
```OpenCypher
MATCH (a)-[e]->(b)
WHERE a.NAME = ''John F Kennedy International Airport''
AND (e.EDGE_KEY > 4 OR b.NAME = ''Philadelphia International Airport'')
RETURN b.NAME AS Name
ORDER BY b.NAME
```  
|Name|
|---|
|Amsterdam Airport Schiphol|
|Dubai International Airport|
|Indira Gandhi International Airport|
|Philadelphia International Airport|  
The following query illustrates the use of string-matching predicates for evaluating international
airports.  
```OpenCypher
MATCH (a)
WHERE a.NAME CONTAINS 'International'
RETURN a.NAME AS Name
ORDER BY a.NAME
```  
|Name|
|---|
|Beijing Capital International Airport|
|Dubai International Airport|
|Indira Gandhi International Airport|
|John F Kennedy International Airport|
|Philadelphia International Airport|"
244;272;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;Graph Algorithms;"
### IS_REACHABLE  
```graphscript
BOOLEAN b = IS_REACHABLE(:g, :v1, :v2);
```  
Determines the reachability between vertices `:v1` and `:v2`.  

### VERTICES / EDGES  
```graphscript
MULTISET<VERTEX> vs = VERTICES(:g);
SEQUENCE<VERTEX> sv = VERTICES(:weighted_path);
MULTISET<EDGE> me = EDGES(:g);
MULTISET<EDGE> es = EDGES(:g, :vsSrc, :vsTgt);
MULTISET<EDGE> mi = IN_EDGES(:v);
MULTISET<EDGE> mo = OUT_EDGES(:v);
```  

### SOURCE / TARGET  
```graphscript
VERTEX v = SOURCE(:e);
VERTEX v = TARGET(:e);
```  

### NEIGHBORS  
```graphscript
MULTISET<VERTEX> nb1 = NEIGHBORS(:g, :v, -1, 2);
MULTISET<VERTEX> nb2 = NEIGHBORS(:g, :v, 0, 2, 'OUTGOING');
MULTISET<VERTEX> nb3 = NEIGHBORS(:g, :v, 1, 15, 'INCOMING');
MULTISET<VERTEX> nb4 = NEIGHBORS(:g, :v, 2, 2, 'ANY');
```  

### Degree Functions  
```graphscript
BIGINT numIncomingEdges = IN_DEGREE(:v);
BIGINT numOutgoingEdges = OUT_DEGREE(:v);
BIGINT numEdgesAnyDirection = DEGREE(:v);
```  

### LABEL  
```graphscript
NVARCHAR n = LABEL(:v);
```  
Returns the label of a given vertex or edge.  

### RANDOM_ELEMENT  
```graphscript
INTEGER random_int = RANDOM_ELEMENT(:ms);
```  
Returns a randomly chosen element from a given multiset or sequence.  

### IS_EMPTY  
```graphscript
BOOLEAN b = IS_EMPTY(:seq);
```  
Returns true if the given multiset, sequence, map or weighted path has no elements.  

### SUBGRAPH  
```graphscript
MULTISET<VERTEX> mv= VERTICES(:g);
GRAPH g1 = SUBGRAPH(:g, :mv);
```  
Induces a subgraph from a set of vertices.  

### INVERSEGRAPH  
```graphscript
GRAPH g1 = INVERSEGRAPH(:g);
```  
Retrieves an inverse graph with all edges flipped.  

### SHORTEST_PATH  
```graphscript
WEIGHTEDPATH<BIGINT> p1
= SHORTEST_PATH(:g, :v1, :v2);
WEIGHTEDPATH<INTEGER> p2
= SHORTEST_PATH(:g, :v1, :v2,
(EDGE e) => INTEGER { return :e.attr; });
```  
Determines the shortest path between two vertices based either on hop distance or on a custom
weight function.  
```graphscript
WEIGHTEDPATH<BIGINT> p3
= SHORTEST_PATH(:g, :v1, :v2, 'ANY');
```  
Determines the shortest path between two vertices irrespective of the connecting edges' direction.  
```graphscript
WEIGHTEDPATH<INTEGER> p4
= SHORTEST_PATH(:g, :v1, :v2, (EDGE e, INTEGER w, BIGINT h) =>
INTEGER{ IF(:w + :e.price < 500 AND :h < 2L) {return :e.price;}
ELSE {END TRAVERSE;}});
```  
Determines the shortest path between two vertices using a custom weight function with bounds on
current weight distance and hop distance. In this example, 'w' is the weight and 'h' is the number
of hops until the previous edge.  

### K_SHORTEST_PATHS  
```graphscript
SEQUENCE<WEIGHTEDPATH<BIGINT>> paths
= K_SHORTEST_PATHS(:g, :v1, :v2, :k);
SEQUENCE<WEIGHTEDPATH<INTEGER>> paths2
= K_SHORTEST_PATHS(:g, :v1, :v2, :k,
(EDGE e) => INTEGER { return :e.attr; });
```  
Determines the top `k` shortest paths between two vertices
either based on hop distance or on a custom weight function.  

### SHORTEST_PATHS_ONE_TO_ALL  
```graphscript
GRAPH g2 = SHORTEST_PATHS_ONE_TO_ALL (
:g, :startVertex, ""WEIGHT"",
(EDGE e) => DOUBLE { RETURN :e.len; },
'INCOMING'
);
```  
Determines the shortest paths between a start vertex and all other reachable vertices
within a given graph traversing the connecting edges in reverse direction.  

### STRONGLY_CONNECTED_COMPONENTS  
```graphscript
SEQUENCE<SEQUENCE<VERTEX>> ssv = STRONGLY_CONNECTED_COMPONENTS(:g);
```  
Computes the strongly connected components in a graph.  
"
245;54;60;20;30;060-020-030-Basic_Vertex_Operations.md;Basic Vertex Operations;IN_EDGES;"Returns all the incoming edges of a vertex.  
- IN_EDGES(VERTEX) => MULTISET  
"
246;63;60;20;40;060-020-040-Basic_Edge_Operations.md;Basic Edge Operations;Edge Attribute Access;"An attribute access expression allows you to retrieve the corresponding attribute value for a given
edge variable and attribute name. The attribute name is an identifier. The return type of the
expression is derived from the underlying specified attribute type.  
```bnf
<attr_access_expr> ::= <variable_reference> . <identifier>
```  

### Examples  
```graphscript
DOUBLE weight = :e.weight;
BIGINT edgeKey = :e.""EDGE_KEY"";
```"
247;12;40;20;0;040-020-000-Drop_Graph_Workspace.md;DROP GRAPH WORKSPACE Statement (Data Definition);;"Drops a graph workspace.  
<!--! section id=""section_dgw_syntax"" -->"
248;208;60;60;0;060-060-000-Restrictions.md;Restrictions for GraphScript Procedures;Size Limits;"The following table shows the maximum allowable limit for each entry.  
|Description|Limit|
|---|---|
|Maximum identifier length|127|
|Maximum number of temporary attributes per graph|64|
|Maximum number of variables|10000|
|Maximum number of graph variables|128|
|Maximum script length (in bytes)|2 GB|  
"
249;82;60;20;60;060-020-060-Built-In_Graph_Algorithms.md;Built-In Graph Algorithms;PageRank;"Computes the score of vertices based on the incoming edges and the scores of the corresponding
source vertices. The algorithm was initially introduced by Google for weighting the importance of
websites. The underlying assumption is that more important sites receive more links from other pages.  
The theory is based on an theoretical person randomly browsing through the sites by clicking links.
At any step, the person has a propability $d$ to continue also called the damping factor. The resulting
scores form a propability distribution representing the likelyhood of the person to arrive a particular
page $v$, denoted as $PR(v)$. Furthermore, if a page has no outgoing links, the algorithm assumes that
the surfer starts randomly at any other page.  
The resulting formula can be written as:
$$PR(v) = \frac{1 - d}{\left|V\right|} + d \sum_{u \in N(v)} \frac{PR\left(u\right)}{L\left(u\right)} $$
where $N(v)$ is the set of vertices which link to $v$ and $L\left(u\right)$ the number of outgoing edges
of vertex $u$.  
The underlying implementation uses this formula to iteratively update a candidate solution until the
iteration limit has been reached or all the values converged. A value is converged if the update
does not deviate by a certain amount epsilon during an iteration.  
```bnf
<page_function> ::= PAGE_RANK '(' <graph_variable>. [, <damping_factor> [ , <iteration_limit>
[ , <epsilon> ] ] ] ')'  
<graph_variable> ::= <variable_reference>
<damping_factor> ::= <double_constant> | <expr>
<iteration_limit> ::= <integer_constant> | <expr>
<epsilon> ::= <double_constant> | <expr>
```  
### Example  
The following example demonstrates the usage of the page rank function.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");  
MAP<VERTEX, DOUBLE> default_rank = PAGE_RANK(:g);
MAP<VERTEX, DOUBLE> custom_rank = PAGE_RANK(:g, 0.20, 1000, 0.00001);
```  
The defaults for the optional parameters are:
|    parameter    |   type     |  default |
|----------------:|:----------:|:---------|
| damping factor  | DOUBLE     |  $0.85$  |
| iteration limit | INT        |  $100$   |
| epsilon         | DOUBLE     |  $10^{-8}$ |  
<!--! section id=""section_shortest_path"" -->"
250;213;60;70;0;060-070-000-Complex_GraphScript_Examples.md;Complex GraphScript Examples;GraphScript Table User-Defined Function Example;"An implementation based on table user-defined functions of the anonymous block example
from above, which computes all the employees who work on projects that produce products
bought by a specific customer, is shown below.  
```sql
CREATE OR REPLACE FUNCTION ""COMPANY_SCHEMA"".""CONTRIBUTING_EMPLOYEES"" (
CUSTOMER_ID BIGINT -- The key of the customer in the ""CUSTOMERS"" table
)
RETURNS TABLE (FIRST_NAME NVARCHAR(100), LAST_NAME NVARCHAR(100))
LANGUAGE GRAPH AS
BEGIN
GRAPH g = GRAPH(""COMPANY_SCHEMA"", ""COMPANY_GRAPH"");
VERTEX v_customer = VERTEX(:g, 'CUSTOMERS', :CUSTOMER_ID);
MULTISET<VERTEX> m_neighbors = NEIGHBORS(:g, :v_customer, 1, 3, 'ANY');
MULTISET<VERTEX> m_employees = v in :m_neighbors where LABEL(:v) == 'Employee';
RETURN SELECT :v.FIRST_NAME, :v.LAST_NAME FOREACH v IN :m_employees;
END;  
SELECT * FROM ""COMPANY_SCHEMA"".""CONTRIBUTING_EMPLOYEES""(?) ORDER BY LAST_NAME, FIRST_NAME;
```"
251;216;70;10;0;070-010-000-OPENCYPHER_TABLE_SQL_Function.md;OPENCYPHER_TABLE SQL Function;Syntax;"```
OPENCYPHER_TABLE (
<graph_workspace_spec>
<opencypher_query_spec>
[<parameters_spec>]
)
```  
<!--! section id=""section_sz2_z1n_xgb"" -->"
252;119;60;50;10;060-050-010-Numeric_Types.md;Numeric Types;;"Each numeric type has a maximum value and a minimum value.
A numeric overflow exception is thrown if a given value is smaller than the minimum allowed value or
greater than the maximum allowed value.  
"
253;93;60;30;10;060-030-010-Multiset.md;MULTISET;;"A multiset is an unordered container, and there is no ordinal position to reference individual
elements of a multiset. Furthermore, it is also possible to declare a nested multiset i.e. a
container with an unordered collection of multisets.  
"
254;192;60;50;80;060-050-080-Time_Functions.md;Date and Time Functions;ADD_SECONDS;"Computes the specified TIMESTAMP value, plus or minus the specified seconds. The value to be added
or subtracted needs to be an INTEGER or a BIGINT.  
- ADD_SECONDS(TIMESTAMP, INTEGER) => TIMESTAMP
- ADD_SECONDS(TIMESTAMP, BIGINT) => TIMESTAMP  
"
255;69;60;20;50;060-020-050-Basic_Weighted_Path_Operations.md;Basic Weighted Path Operations;EDGES;"Returns all edges in a graph.  
- EDGES(WEIGHTEDPATH) => SEQUENCE  
"
256;250;90;40;0;090-040-000-Appendix_C_-_GraphScript_Cheat_Sheet.md;Appendix C - GraphScript Cheat Sheet;General Structure;"
### Graphscript Procedures  
```sql
CREATE PROCEDURE GRAPH_PROC (OUT out_val DOUBLE)
LANGUAGE GRAPH READS SQL DATA AS
BEGIN
-- GraphScript coding goes here
END
```  

### Anonymous Blocks  
```sql
DO (IN in_val BIGINT => ?, OUT out_val BIGINT => ?) LANGUAGE GRAPH
BEGIN
-- GraphScript coding goes here
END
```  

### Table User Defined Functions (TUDF)  
```sql
CREATE OR REPLACE FUNCTION GRAPH_FUNC (in_val NVARCHAR(10))
RETURNS TABLE (col1 NVARCHAR(10), col2 INTEGER)
LANGUAGE GRAPH AS
BEGIN
-- GraphScript coding goes here
RETURN SELECT :v.VERTEX_ID, :v.VERTEX_DEPTH FOREACH v IN VERTICES(:g);
END
```  
"
257;233;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;TOSTRING;"The TOSTRING() function takes a boolean, integer, floating point, date, time or a string value and
converts it to a string.  
```bnf
<tostring_function> ::= TOSTRING '(' <variable_name> '.' <attribute_name> ')'
```  
TOSTRING(NULL) returns NULL. An error is thrown if the parsing fails.  
<!--! section id=""_"" -->"
258;226;70;20;30;070-020-030-Keywords.md;Keywords;Keywords;"|   |   |   |   |   |
|----|----|----|----|----|
|MATCH|WHERE|OR|AND|NOT|
|ALL|IN|RETURN|AS|ORDER|
|BY|ASC|DESC|LIMIT|SKIP|
|WITH|CONTAINS|STARTS|ENDS|SUM|
|AVG|COUNT|MAX|MIN| |  
<!--! section id=""section_fzm_q2d_wbb"" -->"
259;237;70;20;40;070-020-040-Built-In_Functions.md;Built-In Functions;ALL;"The ALL function returns a Boolean result and can be used as a predicate in a WHERE clause.
This function returns true if the given condition is true for all elements in the given collection.
Otherwise, it returns false.  
```bnf
<all_function> ::= ALL '('
<variable_name> IN <relationships_function> WHERE <condition> ')'
```  
The following example shows how to use the ALL function.
If you're only interested in Dubai's direct and indirect ultra-long range connections, you can use
an additional edge filter for all edges of a path.  
```OpenCypher
MATCH p = (a)-[*1..2]->(b)
WHERE a.NAME STARTS WITH ''Dubai'' AND ALL(e IN RELATIONSHIPS(p) WHERE e.DIST_KM > 8000.0)
RETURN DISTINCT b.NAME AS Name
ORDER BY b.NAME
```  
The result is:  
|Name|
|---|
|Dubai International Airport|
|Indira Gandhi International Airport|
|John F Kennedy International Airport|  
<!--! section id=""section_"" -->"
260;145;60;50;60;060-050-060-Numerical_Functions.md;Numerical Functions;;"GraphScript supports several numerical functions that are similar in name and behavior to their SQL
counterparts. The following is a list of the functions and their supported argument and return
types. For details about their functionality, please consult the HANA SQL documentation.  
"
261;94;60;30;10;060-030-010-Multiset.md;MULTISET;Constructors;"Variables of type MULTISET can be initialized with a comma-separated enumeration of elements
within curly brackets.  
```bnf
<multiset_init_expr> ::= '{' <initializer_list> '}'
<initializer_list> ::= <expr> | <initializer_list> , <expr>
```  
```graphscript
INTEGER x = 13;
MULTISET<INTEGER> m1 = {5, 1, 5, :x, 13};
MULTISET<MULTISET<INTEGER>> m2 = {:m1, {2, 3, 1}};
```  
By default, a multiset of a primitive type (INTEGER, BIGINT, DOUBLE, TIMESTAMP, NVARCHAR, and
BOOLEAN) is initialized as empty.  
```graphscript
MULTISET<DOUBLE> m3;
MULTISET<MULTISET<DOUBLE>> m4;
```  
An empty multiset of a primitive type can also be initialized explicitly with the multiset
constructor.  
```graphscript
MULTISET<BIGINT> m5 = MULTISET<BIGINT>();
MULTISET<MULTISET<BIGINT>> m6 = MULTISET<MULTISET<BIGINT>>();
```  
An empty multiset of VERTEX or EDGE type requires a graph variable for initialization.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
MULTISET<VERTEX> m7(:g);
MULTISET<MULTISET<VERTEX>> m8(:g);
```  
Additionally, a multiset can be initialized by an operation or function returning a multiset.  
```graphscript
GRAPH g = GRAPH(""FLIGHTS"", ""GRAPH"");
MULTISET<EDGE> m9 = EDGES(:g);
MULTISET<MULTISET<EDGE>> m10 = {EDGES(:g)};
```  
"
